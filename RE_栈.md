**Q22**  : . 括号生成    任何时候，左括号个数，必须大于等于 右括号个数。即是合法的。所以可以用回溯法。并设定left < right 的条件。
                        每一层可以加一个括号。可以加左，也可以加右，加右要满足left < right 
                        直到 left = 0,right = 0，结束。
        **栈思想** 

**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。