**Q22**  : . 括号生成    任何时候，左括号个数，必须大于等于 右括号个数。即是合法的。所以可以用回溯法。并设定left < right 的条件。
                        每一层可以加一个括号。可以加左，也可以加右，加右要满足left < right 
                        直到 left = 0,right = 0，结束。
        **栈思想** 

**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。



**Q84**    柱状图中最大的矩形
           盲猜：**存下标的单调栈**    **枚举矩形的高度**  
            思想： 关于这种数组中找最大矩形， 的题。  可以明确的是，矩形的高，一定是数组中某元素的值。 
            所以：  只要我们枚举每一个元素作为高，求其最大宽度即可。 
            所以：  这题中， 当我们读到一个元素，他小于之前的元素， 那么之前的元素作为高的矩形就一定已经确定了。因为水桶效应。
            假设有  23547    当i到4的时候栈中是235，发现比5低， 那么以5作为高的矩形就确定了。  所以栈中变为 234 
            假设有  235647   当i到4的时候栈中是2356， 发现比6低，那么以6作为高的矩形就是他本身。 然后栈变为 235， 4<5
                            那么以5作为高的矩形也确定了。 他的右侧边界就是 i-1.也就是6的位置。56组成以5作为高的矩形。
            假设有   212...后序都大于2    当遇到1的是偶栈中是 2， 1<2 那么以2作为高的矩形就是他本身。 然后栈变为1， 2再入栈。.。。。
                            最终假设栈中只保留了  12   那么以2作为高的矩形的右侧边界就是数组边界，因为数组右侧都大于2。
            还有一个题也是类似： 即可以装数组元素作为边沿，找最大矩形可以装多少水。 也是枚举水桶边。 让每一个元素作为边，找最大宽度。



**Q85**     最大矩形  ：  01矩阵中 ： 由1填充的最大矩形。
            1.乍一看是动态规划
            2.其实是单调栈。 而且就是Q84的变行
            把第一行作为初试高度heights[] ,然后求若只有第一行的最大矩形。
            然后第二行，若第二行是1，那么该列的高度就可以加1. 若是0，那么该列的高度就改为0.  每次都通过Q84题来求解heights的最大矩形。
            然后每加入一行，就更新一次heights[]的高度。
            for(int i = 0; i < lenr; i++){
                for(int j = 0; j < lenc; j++){
                    heights[j] = matrix[i][j] == '1' ? heights[j]+1 : 0;
                }
                int a = largestRectangleArea(heights); // 
                ans = Math.max(ans, a);
            }
