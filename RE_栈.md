**Q22**  : . 括号生成    任何时候，左括号个数，必须大于等于 右括号个数。即是合法的。所以可以用回溯法。并设定left < right 的条件。
                        每一层可以加一个括号。可以加左，也可以加右，加右要满足left < right 
                        直到 left = 0,right = 0，结束。
        **栈思想** 

**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。



**Q84**    柱状图中最大的矩形
           盲猜：**存下标的单调栈**    **枚举矩形的高度**  
            思想： 关于这种数组中找最大矩形， 的题。  可以明确的是，矩形的高，一定是数组中某元素的值。 
            所以：  只要我们枚举每一个元素作为高，求其最大宽度即可。 
            所以：  这题中， 当我们读到一个元素，他小于之前的元素， 那么之前的元素作为高的矩形就一定已经确定了。因为水桶效应。
            假设有  23547    当i到4的时候栈中是235，发现比5低， 那么以5作为高的矩形就确定了。  所以栈中变为 234 
            假设有  235647   当i到4的时候栈中是2356， 发现比6低，那么以6作为高的矩形就是他本身。 然后栈变为 235， 4<5
                            那么以5作为高的矩形也确定了。 他的右侧边界就是 i-1.也就是6的位置。56组成以5作为高的矩形。
            假设有   212...后序都大于2    当遇到1的是偶栈中是 2， 1<2 那么以2作为高的矩形就是他本身。 然后栈变为1， 2再入栈。.。。。
                            最终假设栈中只保留了  12   那么以2作为高的矩形的右侧边界就是数组边界，因为数组右侧都大于2。
            还有一个题也是类似： 即可以装数组元素作为边沿，找最大矩形可以装多少水。 也是枚举水桶边。 让每一个元素作为边，找最大宽度。



**Q85**     最大矩形  ：  01矩阵中 ： 由1填充的最大矩形。
            1.乍一看是动态规划
            2.其实是单调栈。 而且就是Q84的变行
            把第一行作为初试高度heights[] ,然后求若只有第一行的最大矩形。
            然后第二行，若第二行是1，那么该列的高度就可以加1. 若是0，那么该列的高度就改为0.  每次都通过Q84题来求解heights的最大矩形。
            然后每加入一行，就更新一次heights[]的高度。
            for(int i = 0; i < lenr; i++){
                for(int j = 0; j < lenc; j++){
                    heights[j] = matrix[i][j] == '1' ? heights[j]+1 : 0;
                }
                int a = largestRectangleArea(heights); // 
                ans = Math.max(ans, a);
            }


 
**Q155**    最小栈  ：push,pop,top getMin 要求可以在常数时间返回栈中最小值。
            使用两个栈，一个按入栈顺序入栈即可，保留所有值，
            再使用一个单调递减栈，当栈为空或者栈顶大于等于x时，x可以入栈。若x大于栈顶，则x不入栈。因为x之前比有更小的值了。
            即使有出栈，也是x先出栈。 
            出栈时，只有当x == peek()时，单调栈才出栈一个。
            注意这里：相等时，x也要入栈单调栈，比如0,2,0 最后一个就必须入栈，如果不入栈，那么单调栈只有一个元素0，当普通栈
            弹出第二个0时，单调栈也会弹出一个0，导致单调栈空了，可实际上，第一个0应该在单调栈中。

            题解评论中，有只用一个栈的，即不能使用额外空间。

            解法2 ： 使用自建的Node(x,min1)头插法来表示一个栈。min表示当前结点到栈底的最小值。
                    如果来一个新的值y, 那么 插入结点应该是 Node(y,min(y,min1)) getMin直接返回head.min即可。
                    弹出时，该min随同y也会消失。
                    该方法仍然属于使用了额外的空间，因为对于每一个结点，我们都多使用了一个数据 min.
            解法3 ： 只使用一个栈，且不多使用栈的空间。
                    每次存入     (x) - min = 差值y  即 x - min = y 每次存入y  初始min = x
                             压入 y后，若 x < min时，再更新 min.
                    
                    弹出：  若栈顶 pop < 0 也就是 x-min1 = y, 然后使用min更新为 min  = x  所以 min1(之前的最小值) = min - y

**Q232**    用栈实现队列 ： 双栈实现队列


**Q316**    去除重复字母  s = "cbacdcbc"  ans = acdb  返回结果必须是字典序最小的选择。
            0. 高位的选择，优于低位。
            1. 首先使用 freq[26]对s进行字符频率统计。然后设置vis[26]数组，表示某个字符是否在栈中，入栈则为true,出栈则为false。
                    栈中不允许出现两个相同的字符。
            2. 然后使用单调递增栈。若某未入栈元素>栈顶，就直接入栈。否则就要进行单调栈的维护，把栈顶出栈。
                出栈还要多一个条件，因为栈中只有一个元素a， 要删除他的条件就是num[i]>0.栈中最少要用一个，这个时候可以不是单增的。
                num[i]在遍历时 num[i]--. 每遍历一个到一个元素，就--。 num总是可以获取到还有多少个元素a还没有遍历。
                那么在出栈时，若一个元素已经遍历完了，没有了。 那么栈中的就是唯一一个，就不能再删除了。这是唯一造成栈不是单增的原因。
                
**Q402**        移掉K位数字  可以移掉任意位的数字，如 10200，可以移除1，剩下 0200， 只是输出是把前导0省略，输出 200
                特点，1432219 ：如果要移除 2位。那么就是移除 43， 移除3位就是移除 432 移除4位就是 4322.
                什么规律？从左到右找第一个，当cur位大于(严格大于)cur+1位时，删除cur位。就一定合算的。
                于是可以设计一个单调栈，且可以双端出队的栈。用数组最好。数字长度为Len,删除k位，那么数组最长len.
                使用top=0表示栈顶。每确定一个不删，就入栈top++。 
                确保top>=0  k>0 
                     for(int i = 1; i < num.length(); i++){
                        char c = num.charAt(i);
                        while( k > 0 && top >= 0 &&  c < stack[top]){ // top 可能为 -1
                                top--;
                                k--;
                        }
                        stack[++top] = c;  // 删除以后再入栈c            
                     }
                top -= k;  // 当i==len时出for循环。此时k可能仍然>0.
                stack[++top] = c;  // 删除以后再入栈c  

                假如输入：1432239 那么删除3位就是 432  删除3位还剩 1239 ,由于后边是递增序列。必然不能删除第4位了。
                于是出for循环时，k = 1 >0  还需要删除一位。那么删除谁呢？
                递增序列，必然删除最大的。即后边的k位。 直接把top-=k即可。
                于是输出就是 0~top的字符。
                
**Q456**     132 模式
    **单调栈**  
            维持一个单调递减的栈。

            由于我们要找  1 3 2 
            栈中保存可能是3 的元素。那么大的值总会使得较小的值弹出。而且弹出的值必定在3的右侧。
            由于其小于3， 我们每次只需要使用 max_2 保存最大的2.  由于我们的入栈规定是，nums[i] > max_2时才入栈，那么栈顶总是大于>max_2的
            所以栈顶总是满足 3 > max_2的。 我们遇到一个心的元素 num[i] ,如果出现 nums[i] < max_2 , 那么一定有
                3 > max_2 > nums[i]. 于是查找成功。

            每次我们都把栈顶当作'3'.  
            维持单调递减栈， 入栈'3'时(大于栈顶)，会导致目前的栈顶'3'出栈。 于是，栈顶变为新的'3'， 出栈的'3'中最大的就是2. 
            若nums[i] < '2'则说明出现了 132

**Q503**   下一个更大元素 II   [1,2,1](循环) -》 [2,-1,2]  
           使用入栈 数组下标的形式，维护点掉递减栈， 每次遇到需要出栈的时候，即找到了这些出栈元素的更大值。

**Q1365**     有多少个 小于当前数字 的数字   