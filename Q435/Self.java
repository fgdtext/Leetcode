

package Q435;

import java.util.Arrays;
/*

少有的可以做的出来的贪心。 贪心难在证明，往往编码简单。

对于区间题，相关的内容是  
1。 两个区间的关系， 相交，相离， 包含
2。 经常使用按区间左端点，或右端点排序然后贪心的方法。贪心的方向 可能从左开始，也可能从右开始。


对于本题：
使用左端点排序。 然后从右侧开始排除的方法。

假设使用左侧排除， 对于第二个区间，若和第一区间相交，则直觉上应该删除第二区间，
因为第一区间左侧不相交其他区间，而第二区间可能和后边相交。这样按照贪心的选择，删除第二区间，可能破除更多的相交可能。
但是若第一区间右端点特别大， 而后序区间，都特别小，那么删除第二区间就是错误的选择。 贪心无法解决。


假设使用右侧排除。 

假设有区间 a,b,c 按照左端点排序。
对于c，b若相交，直觉上应该删除b，因为c右侧不可能有相交区间，b可能和a相交，删除b的结果可能是a,c相离。这样就只删除一个。
而且：由于左端点有序。 有三种情况， a,b相离，ab相交b与c不相交  abc相交
对于情况1，实质上删除b,c都一样。
情况2 : 则b成为最后一个可能产生重叠的区间
情况3 : 若ac不相交， 直接删除b即可。ac分离，直观的看出删除c不能解决问题。
        若ac相交 ：  若删除C, 由于abc左端点有序，那么ab一定仍然相交，b也要删除。 结果是删除 bc
                    而若删除b，然后可能删除a 则不同，虽然abc总是要删除两个区间， 若删除ab， a可能会减少靠前区间的重复可能。
                    而c是最后一个，不可能向左再有重复的可能，保留的价值就大。




*/
class Self2 {
    public int eraseOverlapIntervals(int[][] intervals) {
        int len = intervals.length;
        if(len < 2) return 0;
        if(len == 2){
            if(intervals[0][1] >= intervals[1][0] || intervals[1][1] >= intervals[0][0]) return 0;
            else return 1;
        }
        Arrays.sort(intervals,(a,b)->{
            return a[0] - b[0];
        });
        int ans = 0;
        int[] last = intervals[len-1];
        for(int i = len-2; i >= 0; i--){
            if(intervals[i][1] > last[0]){
                ans++;
            }else{
                last = intervals[i];
            }
        }
        return ans;
    }
}



/*
注意到方法一本质上是一个「最长上升子序列」问题，因此我们可以将时间复杂度优化至O(nlogn)，
具体可以参考「300. 最长递增子序列的官方题解」


题目的要求等价于「选出最多数量的区间，使得它们互不重叠

dp[i] = min(dp[j])+1  j < i && rj <= li  即j的右端点应该小于等于i的左端点，这样就不重复。

本质是 最长上升子序列  可以优化，比较难。 还是贪心更好编码


*/
