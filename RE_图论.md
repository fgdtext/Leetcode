**Q133**     克隆图
             前序递归，进行结点拷贝即可。
             层次遍历，用map：记录新旧结点的映射，来标记一个点是否被复制过。


**Q207**     课程表  ： 拓扑排序
             可以使用常规的拓扑排序，但是说实话，不常写，代码量也偏长。  十分推荐 dfs的拓扑排序。
                public void dfs(int u) {
                    visited[u] = 1;  // 标记结点u正在访问，还没完成全部子节点的访问。
                    for (int v: edges.get(u)) {
                        if (visited[v] == 0) {  // 子节点未访问，则可以访问下去
                            dfs(v);
                            if (!valid) {  // valid是一个全局变量，若上边dfs把valid改为false，说明tuopu失败。
                                return;
                            }
                        } else if (visited[v] == 1) { // ==1,说明遇到了正在访问但是未完成的点，
                            valid = false;            // 这就说明v是父节点，又是子节点，说明遇到了环。
                            return;                     // 修改为false，并返回。
                        }
                    }
                    visited[u] = 2;  // 当所有子节点完成访问，标记访问完了。
                    //如果需要序列，则进行保存。
                   //  ans.addFirst(u) // 使用头插法加入 u. 因为加入结点的顺序恰好和正常顺序逆序。
                    }
                }
                
**Q332**     重新安排行程  ： 一笔画问题  飞机票构成一幅图。然后找到一条路径使用完所有机票。输出每次到达的位置。从JFK出发
             euler问题： 通过dfs，把走过的边标记占用，或者直接删除。当一个结点的所有子结点都访问完了，或者说当一个结点的所有边被标记了，
             那么久输出该点。
                public void dfs(String curr) {
                    while (map.containsKey(curr) && map.get(curr).size() > 0) {
                        String tmp = map.get(curr).poll();
                        dfs(tmp);
                    }
                    itinerary.add(curr);
                }


**Q399**    除法求值
            a->b ：表示a/b   
**并查集**  **a->b->c**
            **d->r->c**
            ad分别是c的两个子节点。
            则 a/d == >  a->c->d   ==> a->c * c -> d == > a->c / d -> c == a/d

            所以分别求 a->c，  d -> c 就是分子和分母。

            按照这个思想，我们可以构造并查集，若一条边分别在两个集合，就把集合合并。

            优化 : 路径压缩。 a-> c的路径可能很长。我们可以通过路径压缩，减少找c的过程。
                HashMap<String,String> p;  // p[x] 记录节点 x 的父节点
                HashMap<String,Double> d;  //d[x] 记录节点 x 到父节点的距离（即 x / y）
            只有通过 find(a)查询的结点，才会被重新连接到 root根节点上。
            在算a/b时，要通过find(a),find(b)函数查看是否同属于一个集合。查询后，a/b一定连接在同一个root节点上。
            此时d.get(a),就是a/root,d.get(b)就是b/root

**并查集**
**Q765**    情侣牵手  
                假设有两对情侣发生了交换。 那么只交换一次，就能归位
                假设有三对情侣之间发生了交换，那么需要交换两次。 才能归位。
                若共有n对情侣， 其中有k对情侣互相交换，那么需要k-1次交换，才能归位。
                k对情侣互相交换是什么情况。 是指，任意其中 k-i对的情侣无论如何交换都无法归位。也就是说
                其中有人被换到了不属于这k-i对的范围内。 而是换到另外i对中。

                这种情况可以用并查集来表示。 假设有 n对椅子。  从0 ~ 2*n-1 个椅子。 下标01是一对， 下标23是一对，依次类推。
                现在坐在上边的人就是 01，23，。。。现在对人进行交换。 [0, 2, 1, 3]  
                如何连接并查集， 对于第一对椅子，现在坐着 0，2  这俩人不是情侣。 对0/2 = 0 2/2 =1  说明这俩人一个属于第0对
                一个属于第1对。 说明第0对和第1对发生了交换。 把集合 0 ， 1合并。即第0对椅子和第1对椅子是同一个集合了。

                最后ans = n - 并查集个数。

**迪杰斯特拉算法模板**
**Q778**     水位上升的泳池中游泳  ：在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度
                    当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，
                    但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离。你从坐标方格的左上平台 (0，0) 出发。
                    最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？
                    grid[i][j] 是 [0, ..., N*N - 1] 的排列. 也就是说，没有重复的高度。
            其实就是求起点到终点的所有路径中平台的最大值集合中，取平台最大值是各个平台中最小的那个。就是起点到终点的距离。
            1. 使用回溯法，是可以的。但是复杂度太高。
                    PriorityQueue<int[]> pq  int[] ：{x,y,d}   点x,y到已经确认集合的最短距离为 d。优先队列按照d排序。
                    每次都取最小的加入到集合中。 然后使用该xy点作为集合中一点，更新到他邻点的距离。加入优先队列。
            2. 二分法： 平台的高度最小是0，最大len. 那么ans高度必然在0到len之间。 通过二分高度。 mid = （left+right)/2
                     若水的高度是mid。 然后从启动到终点通过  层次遍历。 看水的高度是mid时，能否到达终点。不能说明mid小了。
                     否则说明大了. ans每次取最小值可以到达的最小值。
            3. 并查集。模拟水位上升的过程。
                        index[grid[i][j]] = getIndex(i, j);  grid[i][j] = h, 
                        等价于  index[h] = getIndex(i, j)    下标h是高度。 值是 h出现在图中的 索引。
                        我们枚举高度时， 就可以通过 index[h]，直到水位为h的点在图中什么位置。(高度不重复)
                        所以 index是 高度：位置 的映射。
                        当水位是h时，我们获取其对应点的位置是 x,y. 若水位高于四个邻接点，那么就合并到一个集合。最终当
                        起点和终点在一个集合的时候，说明水位到达了。
**并查集 & 迪杰斯特拉**  
**Q1631**    最小体力消耗路径 ： 基本和Q778相同。 
            二分法来写的话，其实是比较好理解的。并查集的转化问题，有时不好处理。
            由于我们需要找到从左上角到右下角的最短路径，因此我们可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当我们加入一条权值为 x 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 x 即为答案。
            最短路径就不写了， 能不用就不用。

**并查集**      
**Q839**    相似字符串组
            如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似
            相似，则可以归到一个集合中。如果x,y相似，y,z相似。 那么xyz在同一个集合内。 称为一组。问最后有多少组。
            并查集直接遍历连接一遍 即可。

**并查集**
**Q947**    移除最多的同行或同列石头  ：n 块石头放置在二维平面中的一些整数坐标点上。 若同行或者同列，有其他石头，那么该石头
                可以被移除。  问，当前矩阵中，最多可以移除多少个石头。
            分析： 我们规定，若两个石头，同行或者同列， 那么两颗石头属于同一个集合。 
            那么对于一个集合的石头， 最后最少可以保留 一个石头。 其他石头一定可以被清除掉。
            所以就是，一个并查集，可以保留一颗。  那么可以移除的石头数就是，ans = n - 并查集个数。

**Q959**     由斜杠划分区域   一个方框划分为 0,1,2,3上右下左四个区域。 方块内如果是'\'那么01，23是相连的。‘/’同理。
                方块之间的相连情况是： 1连向右边一个方块的3. 2连向下边一个方块的0. 这样把所有方块内，方块间的关系连在一起。
                就完成了并查集的 合并。
**Q1202**     交换字符串中的元素:pairs[i] = [a, b] 表示字符串中的两个索引.可以 任意多次交换 在 pairs 中任意一对索引处的字符
                返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。  

                我们这么想， 若 a 属于集合 set(a) ,b属于 集合 set(b) ，那么ab就会将两个集合合并在一起，要一起参与排序。所以恰好是并查集。
                关于排序: 使用int[26] 对每个集合分配一个 int[26] s
                将集合中的所有下标，统计其字符频率， 那么最后的顺序就是  int[26]的顺序组合。
                        // 这个时间挺快，但是空间利用率比较差。 lens是：字符串长度。map中不是root的行是空的。
                        int[][] map = new int[lens][26];
                        for(int i = 0; i < lens; i++){
                            int root = find(i);
                            map[root][s.charAt(i)-'a']++;
                        }
                拼接： ansStr  我们通过下标i确定ansStr的每一位应该用什么字符。 如果i的跟是root. 
                    那么在root的字符频率表中即int[] freq = map[root]  在freq中找第一个字符频率不为0的字符。就是
                    位置i应该设置的字符。然后对频率--。


**并查集的使用说明**
            1. 百分之80的图论题，可以用并查集来解决。 
            2. 并查集是集合问题，题意中一般都会涉及到，划分集合的动作。如牵手，可达，并集，相似，等等。
            3. 二维图论中并查集的使用，二维图中一般都是双坐标 (x,y)。 我们一般会做一个坐标映射，getindex(x,y) = index. 
                    用来表示该点在并查集数组中的下标。二维到一维的映射。
