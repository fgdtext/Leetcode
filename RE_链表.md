**Q19**  : . 删除链表的倒数第 N 个结点
            1. 通过 后序 递归，可以直到一个结点后边有几个结点， 若一个节点后边有n个结点，则该结点的下一个就是要删除的结点。
            2. 类似于快慢指针， 让right先走n个，让后left和right一块走，这样两指针距离就是2. 那么当right走到最后一个结点，left
                left的下一个结点就是要删除的结点。

**Q23**   :   合并K个升序链表  
        hard :
               1. 采用自底向上的分治策略， 合并整个list的结果， 等价于 先合并左侧的结果 合并右侧的结果，这两个结果的合并等于整个list合并。
               2. 采用小顶堆的思想， 我们每次只把一个链表的第一个结点丢入堆中，那么堆顶是最小的一个结点。取出该点连接在tail上，
                    然后把该点的下一个结点丢入堆中，这样以此类推，堆顶总能取到最小的结点。直到堆为空位置。tail后边会一个一个接上更大的元素。
**Q24** . 两两交换链表中的节点
            使用一个头结点来统一操作。 while(cur != null && cur.next != null)
                cur是第一个结点，cur.next是第二个节点，交换这两个结点，总是需要他们的前驱结点。

**Q61**    旋转链表k个  : 类似于数组旋转一样。12345 -》 45123 转2个
           由于k可能大于链表长度，那么我们可以使用指针，当他走到null时，恰好可以得到链表长度，此时对k求余数。
           然后令p重新走k个， 然后q从head开始走，pq保持同步移动，当p再次走到头时，q恰好位于应该断开的位置的左侧。
            q.next就是新的头结点。


**Q82**    删除排序链表中的重复元素 II
            链表的题就是看起来不难，但是极容易出错的题目。 
            1. 一定要善用哨兵结点。
            2. 断开和连接的顺序
            3. 强制置空。为了避免出现循环。



