**Q19**  : . 删除链表的倒数第 N 个结点
            1. 通过 后序 递归，可以直到一个结点后边有几个结点， 若一个节点后边有n个结点，则该结点的下一个就是要删除的结点。
            2. 类似于快慢指针， 让right先走n个，让后left和right一块走，这样两指针距离就是2. 那么当right走到最后一个结点，left
                left的下一个结点就是要删除的结点。

**Q23**   :   合并K个升序链表  
        hard :
               1. 采用自底向上的分治策略， 合并整个list的结果， 等价于 先合并左侧的结果 合并右侧的结果，这两个结果的合并等于整个list合并。
               2. 采用小顶堆的思想， 我们每次只把一个链表的第一个结点丢入堆中，那么堆顶是最小的一个结点。取出该点连接在tail上，
                    然后把该点的下一个结点丢入堆中，这样以此类推，堆顶总能取到最小的结点。直到堆为空位置。tail后边会一个一个接上更大的元素。
**Q24** . 两两交换链表中的节点
            使用一个头结点来统一操作。 while(cur != null && cur.next != null)
                cur是第一个结点，cur.next是第二个节点，交换这两个结点，总是需要他们的前驱结点。

    