package Q371;

public class Self {
    public static void main(String[] args) {
       // System.out.print(-16 >>> 1);

        // System.out.println();
        // System.out.print(a ^ (1 << 31));
    }
    public void test(){
        int a = -16;
        for(int i = 0; i < 31; i++){
            if(i % 8 == 0) System.out.print(" ");
            System.out.print((a&(1 << i)) == 0 ? 0 : 1);
        }
        //  -16:   00001111 11111111 11111111 1111111 (反向打印的)
    }
}

// java 中左移 是不移动符号位的。
/*
>>> ： 当作无符号数进行右移动。
>> : 符号位不动，右移
<< : 符号位不动，左移

注意 :  我们所能直接操作的负数， java在操作时，本就是补码表示的。
    也就是说，我们压根就不需要去求补码来表示。
    所以在计算 a+b  时，本来就是两个补码在计算。 如果是结果是负数，那么直接返回该补码即可。
    a取到的是补码， 存进去也应该是补码。
*/

/*
哇哇哇哇哇哇，苦楚啦了。 

利用位操作实现加法
首先看十进制是如何做的： 5+7=12，三步走

第一步：相加各位的值，不算进位，得到2。
第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。
同样我们可以用三步走的方式计算二进制值相加： 5---101，7---111

第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
第二步：计算进位值，得到1010，相当于各位进行与操作得到101，再向左移一位得到1010，(101&111)<<1。
第三步重复上述两步，各位相加 010^1010=1000，进位值为100=(010 & 1010)<<1。
继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
结束条件：进位为0，即a为最终的求和结果。


注意： 该算法为什么对负数也是有效的。 

补码的意义： 补码的存在就是为了消除符号带来的差异。使得处理负数和处理正数是统一的。
    当转换为补码时：都是无符号的数字。所以操作时统一的。

*/

//  不用加法 计算 a+b 

class Solution {
    public int getSum(int a, int b) {
        while(b != 0){
            int t = a;
            a = a ^ b;
            b = (t & b) << 1;
        }
        return a;
    }
}




// 严格意义上，还是用了 加法的。 所以不合格。
class Self2 {
    public int getSum(int a, int b) {
        int c = 0;
        int ans = 0;
        for(int i = 0; i < 32; i++){
            int al = a & 1;
            int bl = b & 1;
            ans |= ((al^bl^c) << i);
            if(al + bl + c >= 2) c = 1;
            else c = 0;
            a >>= 1;
            b >>= 1;
        }
        return ans;
    }
}
