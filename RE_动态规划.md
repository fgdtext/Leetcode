**Q10** ： 正则表达式匹配  MD:字符串
**Q5** ： 最长回文子串。 MD:字符串
**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。


**Q62**    不同路径
         **杨辉三角**      
            每个位置的路径总数 = 该位置左边的路径总数 + 该位置上边的路径总数
            其实就是爬楼梯题的变行，这个是二维的。


**Q64**     最小路径和
            还是动态规划
            这个和**Q62**的不同之处就是，上边是求总数，不需要左选择。
            相同点都是，左上角到右下角，只能2方向搜索。 这一点给了我们通过迭代dp的机会。
            假设该题是4方向的，起点和终点不是在角落，那么要迭代dp就不行了，因为填表顺序太复杂，各个方向都有依赖。但是可以通过递归记忆化来解决。递归记忆化就是为了解决这种计算顺序无法掌握的情况。
            该题在一点要做这样的选择 dp[i][j] = min(dp[i+1][j],dp[i][j+1])+m[i][j];
            不再是简单的求和。
**Q91**     解码方法  12335323131332 -> abaasdasd   数字到字符的映射。有多少种解码方法。
            其实就是爬楼梯 的改编。



**总共6题股票问题**
 **双dp问题**      money[i]: 第i天结束时，持有钱的数目。 hold[i]: 第i天结束时，持有股票的数目。
                   卖出：+prices[i]  ,买入：-prices[i]
       
**Q121**    买卖股票的最佳时机I  ：  **只能买入和卖出一次**。
            方法1 ：  使用滑动窗口， left < right, 然后left永远指向right之前的最小值。 只有在right遇到更小值时，left移动到right的位置。，这样就可以得到数组中，求得 num[right] - num[left]  的最大值。
            方式2 ： 动态规划，可以压缩到只使用常数个变量。 用不着。因为只能买入和卖出一次。
            
**Q122**    买卖股票的最佳时机 II  ： 必须卖出后，才能重新买入。 **可以多次买卖股票**
            **股票可以在同一天买入和卖出**
            贪心： 只要价格高于买入价格， 就卖掉。假设三天的价格是 7 8 9 买入7，卖出8，再买入8，卖出9 总差价就是2. 等价于7买入，9卖出。
            所以，只要今天比昨天高，就计入利润。
            使用动态规划也是可以的。

**Q123**    买卖股票的最佳时机 III  : **最多做两笔交易**
            **股票可以在同一天买入和卖出**  ： 
                    int buy1 = -prices[0], sell1 = 0;
                    int buy2 = -prices[0], sell2 = 0;
                    for (int i = 1; i < n; ++i) {
                        buy1 = Math.max(buy1, -prices[i]);
                        sell1 = Math.max(sell1, buy1 + prices[i]);
                        buy2 = Math.max(buy2, sell1 - prices[i]);
                        sell2 = Math.max(sell2, buy2 + prices[i]);
                    }
                    return sell2;
            在计算sell1的时候，为什么要使用刚刚更新过的buy1呢？？？这就是巧妙的地方，我们允许今天买入的股票，在今天卖出。
            在计算buy2的时候， 我们又使用刚更新过的sell1, 这就表明，我们今天卖出了， 但是还可以继续买入。
            sell2也是同理。
            那么最后我什么返回sell2呢？ 一定是做了两笔交易，才能取得最大利润吗?
            不： 得益于上边的设定， 我们总是能得到当天完成两笔交易时取得的最大利润。 因为我们能同一天，完成一笔不赔也不赚的交易。
            这就是，不设置冷冻期的好处。

**Q188**    买卖股票的最佳时机 IV ： **最多做K笔交易**
            Q123的增强。 变为buy[i], sell[i],即可


**Q714**     买卖股票的最佳时机含手续费  : 不限制交易次数，无冷冻期，有手续费。
             我们设定在卖出出，扣除手续费。
             这样这道题就和 **Q122** 一样了。

**Q309**     最佳买卖股票时机含冷冻期  ： 不限制交易次数，但是卖出股票后，无法在第二天买入。
            这题因该分3个状态：  1. 持有股票   2. 不持有股票，并且处于冷冻期的收益， 3.不持有股票，不在冷冻期的最大收益。
             f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i]);  // 要持有股票，只能是从已经持有股票，或者从不在冷冻期转来
             f[i][1] = f[i - 1][0] + prices[i]; // 如果今天处于冷冻期，说明是昨天卖了股票。
             f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]); // 

**Q131**     分割回文串 : 对串分割，要求所有子串都是回文串，返回所有方案。
             1. 首先，我们通过dp获得所有子串是否是一个回文串。dp[i][j] = true 则子串ij为回文串。
             2. 通过回溯的 begin写法， 以当前位置为起点，准备分割下一个回文串。终点有很多选择。只要dp[i][j] = true即可。
             3. 当cur == len时，说明已经分割完毕。存入list即可。



**Q139**     单词拆分  s = "leetcode", wordDict = ["leet", "code"] wordDict不重复，但是每个单词可以重复使用。
                    问：是否可以分割完毕。
             使用动态规划： dp[i]：0到i是否可以分割完毕。 
             转移方程 ： if(dp[j]) dp[i] = set.contains(s.substring(j+1, i+1));  如果dp[j] = true,且j+1到i在集合种，那么可以划分成功。
        **单词拆分II**  : 这个题不是求是否可以划分，而是得出所有的划分结果，所以动态规划就不行了， 要使用回溯法递归了。但是可以参考
                        回文串的划分，先使用动态规划得到可划分区域 dp[i] 在dp[i]可划分的位置进行切割。其余位置直接跳过。
                    
**Q152**   乘积最大子数组    当数组有0的时候，前缀积是没有意义的。
            所以使用动态规划： 
            1. 最容易想到的一个方式是，dp[i][j],表示i~j的乘积， 然后使用max在dp中找最大值。时间o(n^2)
            2. dp[i] : 表示0~i之间存在的最大成绩，子数组不一定以i结尾 更新时dp[i] = max(dp[i-1], 以i结尾的最大成绩)
                        找 以i结尾的最大乘积需要o(n),所以总时间为o(n^2)
            3. error : dp[i] : 表示以i结尾的（子数组必须包含i），最大乘积。那么转移方程是：
                        num = 0,则dp[i] = 0   num != 0  则dp[i] = Math.max(dp[i-1]*num, num);
                        但是很容易就可以发现这样定义是错的。 例如 -2，3-4， 3结尾的最大乘积是3， 但是-4的最大乘积是 24， 
                        而用以上方法得到的是  3*（-4） 和 （-4）选最大，由于在算3的时候已经丢掉了-2，那么导致-4是错的。
                        所以我们需要把正负进行分开。
            4. 是两个dp， max记录以i结尾的最大子数组。min记录以i结尾的最小子数组。min就可以保留负值了。
                            最大不一定是正数，最小不一定是负数。
                                    if(nums[i] == 0){
                                        max = min = 0;
                                    }else if(nums[i] > 0){
                                        int ma = max, mi = min;
                                        // 前一个最大的 可能也是 负数
                                        max = Math.max(ma*nums[i], nums[i]);
                                        min = Math.min(mi*nums[i], nums[i]);
                                    }else{
                                        int ma = max, mi = min;
                                        max = Math.max(mi*nums[i], nums[i]);
                                        min = Math.min(ma*nums[i], nums[i]);
                                    }
                        即：当num > 0 以i结尾的最大子数组，只可能是从以i-1结尾的最大子数组，或者子数组是他本身转化来的。
                            当num < 0 以i结尾的最大子数组, 只可能是从以i-1结尾的最小子数组，或者子数组是他本身转化来的。
                            最小子数组也同理。


**Q198**      打家劫舍  相邻两家同时被偷，会报警。钱数：[1,2,3,1] 最多偷 1+3 = 4 
                有两种dp方式
              1.  dp[i]: 表示前i家最多可以偷多少。 则第i家的转移有两种
                        第i家不偷， dp[i] = dp[i-1]
                        第i家偷  ，dp[i] = dp[i-2] + nums[i]
                        那么两种情况取最大值，即可。
                        可以用滚动数组两个变量保存 i-1,i-2即可。
             2. 模仿股票问题，使用双dp数组，  **比较简单的设法。我觉的也会比较通用。**
                        get[i] : 如果偷第i家，前i家最多偷多少
                      no_get[i] ：不偷第i家，前i家最多偷多少。
                    那么转移方程是
                      get[i] = no_get[i-1]+nums[i] // 昨天只能是不偷转移来的。
                      no_get[i] = max(no_get[i-1], get[i-1]) // 昨天可能也没偷，也可能偷了。

**背包**

**Q279**         完全平方数 13 = 9 + 4  用最少的完全平方数使得其和为 n。
                 这是一个数论问题，但是数论解法太高深了，看不懂。 所以看作背包问题比较好。即k这个数的平方要不要背的问题。
                  dp[i] = Math.min(dp[i], dp[i - k*k]+1);


**Q322**         零钱兑换  完全背包问题。
                        for(int i = 1; i <= amount; i++){
                            for(int j = 0; j < coins.length && coins[j] <= i; j++){
                                dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1);
                            }
                        }
                  因为可以重复选同一种硬币，说明，每次选硬币时，他可以用每一个硬币。只要该硬币面值 <= i即可。



**LIS: 最长上升子序列**

**Q300**         最长递增子序列
                 tails[k] 的值代表 长度为k+1 子序列 的 最小 尾部 元素值。  
                 长度为k+1的子序列的最小尾部元素 必然 大于 > 长度为k的子序列的最小尾部元素。
                    int res = 0;  
                    // 对于每一个num 更新tails数组
                    for(int num : nums) {
                        // 在tails数组的 0~res之间二分查找 tails[k] >= num
                        // 找第一个大于等于num的位置。
                        int i = 0, j = res;   //  若存在则更新位置i ,若不存在，则i == res 更新的就是res 的位置。
                        while(i < j) {
                            int m = (i + j) / 2;
                            if(tails[m] < num) i = m + 1;  // m的位置小于num, 说明第一个大的一定在m的右侧。
                            else j = m;   // m的位置大于等于num  ，则第一个大的一定在左侧或则就是m. 
                            // 若m左侧元素都小于num,则最终一直更新i到现在j=m的位置。
                            // 若左侧元素等于num, 则j一直左移动，直到最左边等于num的位置。
                        } 
                        // 若不存在，则更新的是 tails[res] 下边会使得res+1.  
                        tails[i] = num;
                        // 若res == j 说明在 [0~res)中不存在 tails[k] > num 则序列长度+1.
                        if(res == j) res++;  // res == i也一样
                        // 这里有一个问题，就是该判断使得，该代码只能找 严格递增的，出现相等的，j的位置是在(0~res)之间，则res不会增加。
                    }

**Q334**        递增的三元子序列
                Q300的简化。k = 3即可。设一个dp[2]数组即可。当出现num>dp[1]时，dp[1]:说明现在已经有长度为2的子序列了。
                    而num>dp[1]说明，num不能更新dp[1],应该更新dp[2],说明存在长度为3的子序列了。而dp[2]不需要更新，直接返回true即可。
                        若一直无法更新dp[2]的位置，说明不存在长度为3的序列。
