
**Q10** ： 正则表达式匹配  MD:字符串

**Q5** ： 最长回文子串。 MD:字符串

**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。


**Q62**    不同路径
         **杨辉三角**      
            每个位置的路径总数 = 该位置左边的路径总数 + 该位置上边的路径总数
            其实就是爬楼梯题的变行，这个是二维的。


**Q64**     最小路径和
            还是动态规划
            这个和**Q62**的不同之处就是，上边是求总数，不需要左选择。
            相同点都是，左上角到右下角，只能2方向搜索。 这一点给了我们通过迭代dp的机会。
            假设该题是4方向的，起点和终点不是在角落，那么要迭代dp就不行了，因为填表顺序太复杂，各个方向都有依赖。但是可以通过递归记忆化来解决。递归记忆化就是为了解决这种计算顺序无法掌握的情况。
            该题在一点要做这样的选择 dp[i][j] = min(dp[i+1][j],dp[i][j+1])+m[i][j];
            不再是简单的求和。
**Q91**     解码方法  12335323131332 -> abaasdasd   数字到字符的映射。有多少种解码方法。
            其实就是爬楼梯 的改编。



**总共6题股票问题**
 **双dp问题**      money[i]: 第i天结束时，持有钱的数目。 hold[i]: 第i天结束时，持有股票的数目。
                   卖出：+prices[i]  ,买入：-prices[i]
       
**Q121**    买卖股票的最佳时机I  ：  **只能买入和卖出一次**。
            方法1 ：  使用滑动窗口， left < right, 然后left永远指向right之前的最小值。 只有在right遇到更小值时，left移动到right的位置。，这样就可以得到数组中，求得 num[right] - num[left]  的最大值。
            方式2 ： 动态规划，可以压缩到只使用常数个变量。 用不着。因为只能买入和卖出一次。
            
**Q122**    买卖股票的最佳时机 II  ： 必须卖出后，才能重新买入。 **可以多次买卖股票**
            **股票可以在同一天买入和卖出**
            贪心： 只要价格高于买入价格， 就卖掉。假设三天的价格是 7 8 9 买入7，卖出8，再买入8，卖出9 总差价就是2. 等价于7买入，9卖出。
            所以，只要今天比昨天高，就计入利润。
            使用动态规划也是可以的。

**Q123**    买卖股票的最佳时机 III  : **最多做两笔交易**
            **股票可以在同一天买入和卖出**  ： 
                    int buy1 = -prices[0], sell1 = 0;
                    int buy2 = -prices[0], sell2 = 0;
                    for (int i = 1; i < n; ++i) {
                        buy1 = Math.max(buy1, -prices[i]);
                        sell1 = Math.max(sell1, buy1 + prices[i]);
                        buy2 = Math.max(buy2, sell1 - prices[i]);
                        sell2 = Math.max(sell2, buy2 + prices[i]);
                    }
                    return sell2;
            在计算sell1的时候，为什么要使用刚刚更新过的buy1呢？？？这就是巧妙的地方，我们允许今天买入的股票，在今天卖出。
            在计算buy2的时候， 我们又使用刚更新过的sell1, 这就表明，我们今天卖出了， 但是还可以继续买入。
            sell2也是同理。
            那么最后我什么返回sell2呢？ 一定是做了两笔交易，才能取得最大利润吗?
            不： 得益于上边的设定， 我们总是能得到当天完成两笔交易时取得的最大利润。 因为我们能同一天，完成一笔不赔也不赚的交易。
            这就是，不设置冷冻期的好处。

**Q188**    买卖股票的最佳时机 IV ： **最多做K笔交易**
            Q123的增强。 变为buy[i], sell[i],即可


**Q714**     买卖股票的最佳时机含手续费  : 不限制交易次数，无冷冻期，有手续费。
             我们设定在卖出时，扣除手续费。
             这样这道题就和 **Q122** 一样了。

**Q309**     最佳买卖股票时机含冷冻期  ： 不限制交易次数，但是卖出股票后，无法在第二天买入。
            这题因该分3个状态：  1. 持有股票   2. 不持有股票，并且处于冷冻期的收益， 3.不持有股票，不在冷冻期的最大收益。
             f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i]);  // 要持有股票，只能是从已经持有股票，或者从不在冷冻期转来
             f[i][1] = f[i - 1][0] + prices[i]; // 如果今天处于冷冻期，说明是昨天卖了股票。
             f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]); // 

**Q131**     分割回文串 : 对串分割，要求所有子串都是回文串，返回所有方案。
             1. 首先，我们通过dp获得所有子串是否是一个回文串。dp[i][j] = true 则子串ij为回文串。
             2. 通过回溯的 begin写法， 以当前位置为起点，准备分割下一个回文串。终点有很多选择。只要dp[i][j] = true即可。
             3. 当cur == len时，说明已经分割完毕。存入list即可。



**Q139**     单词拆分  s = "leetcode", wordDict = ["leet", "code"] wordDict不重复，但是每个单词可以重复使用。
                    问：是否可以分割完毕。
             使用动态规划： dp[i]：0到i是否可以分割完毕。 
             转移方程 ： if(dp[j]) dp[i] = set.contains(s.substring(j+1, i+1));  如果dp[j] = true,且j+1到i在集合种，那么可以划分成功。
        **单词拆分II**  : 这个题不是求是否可以划分，而是得出所有的划分结果，所以动态规划就不行了， 要使用回溯法递归了。但是可以参考
                        回文串的划分，先使用动态规划得到可划分区域 dp[i] 在dp[i]可划分的位置进行切割。其余位置直接跳过。
                    
**Q152**   乘积最大子数组    当数组有0的时候，前缀积是没有意义的。
            所以使用动态规划： 
            1. 最容易想到的一个方式是，dp[i][j],表示i~j的乘积， 然后使用max在dp中找最大值。时间o(n^2)
            2. dp[i] : 表示0~i之间存在的最大成绩，子数组不一定以i结尾 更新时dp[i] = max(dp[i-1], 以i结尾的最大成绩)
                        找 以i结尾的最大乘积需要o(n),所以总时间为o(n^2)
            3. error : dp[i] : 表示以i结尾的（子数组必须包含i），最大乘积。那么转移方程是：
                        num = 0,则dp[i] = 0   num != 0  则dp[i] = Math.max(dp[i-1]*num, num);
                        但是很容易就可以发现这样定义是错的。 例如 -2，3-4， 3结尾的最大乘积是3， 但是-4的最大乘积是 24， 
                        而用以上方法得到的是  3*（-4） 和 （-4）选最大，由于在算3的时候已经丢掉了-2，那么导致-4是错的。
                        所以我们需要把正负进行分开。
            4. 是两个dp， max记录以i结尾的最大子数组。min记录以i结尾的最小子数组。min就可以保留负值了。
                            最大不一定是正数，最小不一定是负数。
                                    if(nums[i] == 0){
                                        max = min = 0;
                                    }else if(nums[i] > 0){
                                        int ma = max, mi = min;
                                        // 前一个最大的 可能也是 负数
                                        max = Math.max(ma*nums[i], nums[i]);
                                        min = Math.min(mi*nums[i], nums[i]);
                                    }else{
                                        int ma = max, mi = min;
                                        max = Math.max(mi*nums[i], nums[i]);
                                        min = Math.min(ma*nums[i], nums[i]);
                                    }
                        即：当num > 0 以i结尾的最大子数组，只可能是从以i-1结尾的最大子数组，或者子数组是他本身转化来的。
                            当num < 0 以i结尾的最大子数组, 只可能是从以i-1结尾的最小子数组，或者子数组是他本身转化来的。
                            最小子数组也同理。



**打家劫舍**

**Q198**      打家劫舍  相邻两家同时被偷，会报警。钱数：[1,2,3,1] 最多偷 1+3 = 4 
                有两种dp方式
              1.  dp[i]: 表示前i家最多可以偷多少。 则第i家的转移有两种
                        第i家不偷， dp[i] = dp[i-1]
                        第i家偷  ，dp[i] = dp[i-2] + nums[i]
                        那么两种情况取最大值，即可。
                        可以用滚动数组两个变量保存 i-1,i-2即可。
             2. 模仿股票问题，使用双dp数组，  **比较简单的设法。我觉的也会比较通用。**
                        get[i] : 如果偷第i家，前i家最多偷多少
                      no_get[i] ：不偷第i家，前i家最多偷多少。
                    那么转移方程是
                      get[i] = no_get[i-1]+nums[i] // 昨天只能是不偷转移来的。
                      no_get[i] = max(no_get[i-1], get[i-1]) // 昨天可能也没偷，也可能偷了。

**Q337**     打家劫舍 III  二叉树的结构，直接相连的两家被偷，就会报警。
             二叉树结构，用数组的话，不好掌握计算顺序。所以使用记忆化递归。 记住：get,no_get两种情况可以偷多少。
             然后向上层返回，父节点根据子节点的情况再向上返回。所以使用递归的后序方式。
                    int[] l = dfs(node.left);
                    int[] r = dfs(node.right);
                    int selected = node.val + l[1] + r[1];
                    int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
                    return new int[]{selected, notSelected}





**背包**

**Q279**         完全平方数 13 = 9 + 4  用最少的完全平方数使得其和为 n。
                 这是一个数论问题，但是数论解法太高深了，看不懂。 所以看作背包问题比较好。即k这个数的平方要不要背的问题。
                  dp[i] = Math.min(dp[i], dp[i - k*k]+1);


**Q322**         零钱兑换  完全背包问题。
                        for(int i = 1; i <= amount; i++){
                            for(int j = 0; j < coins.length && coins[j] <= i; j++){
                                dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1);
                            }
                        }
                  因为可以重复选同一种硬币，说明，每次选硬币时，他可以用每一个硬币。只要该硬币面值 <= i即可。

**Q416**        分割等和子集 ： 是否可以把数组分为两个子集，使得其和相等。
 **好题**
                1.先排序，这就不说了。 再求出总和sum， 然后呢？
                2.现在问题已经变为，0-1背包的 硬币问题，是否存在一种选择，使用这些硬币凑够 sum/2
            **dp方程**  dp[i][j] = dp[i-1][j] | dp[i-1][j-nums[i]];   //只依赖于上一行的 01背包问题。
                        如果不选第i个数，那么前i个数中拼为j,的状态就和上一行的状态相同。
                        选第i个数字，那么 若前 i-1个数字，能拼为j-nums[i], 那么前i个数字，就能拼为 j.

                        int target = sum / 2;
                        boolean[] dp = new boolean[target+1]; // 使得背包恰好装满
                        dp[0] = true;
                        for(int i = 1; i < nums.length; i++){
                            for(int j = target; j >= nums[i]; j--){
                                dp[j] = dp[j] | dp[j-nums[i]];
                            }
                        }
                        return dp[target];

**Q494**       目标和  nums: [1, 1, 1, 1, 1], S: 3   给数组中每一个元素 +或者-号，使得整个数组的和 为S。 返回方法数。
                1. 初看是回溯法，子集生成，每次都选出的集合为正集合。然后最后算看和是否是  S。 回溯法太慢了。
                2. 使用动态规划。 dp[i][j] = k: 表示前i个数字，赋予符号，最终凑够和为j ，总共有k种方法。
                当dp[i-1][]确定时， 第i个物品有两种方案，给正号，或者给 负号。
                dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][abs(j-nums[i])]  
                假设 j = 5  nums[i] = 2    
                        找 j-nums[i] = 3 的方案数。 [3],+2 = 5
                        找 j+nums[i] = 7 的方法数   [7],-2 = 5
                假设 j = 5  nums[i] =  6
                        找 j+nums[i] = 11 的方案数  [11],-6 = 5
                        找 j-nums[i] = -1 的方案数  [-1],6  = 5
                        但是问题是 dp数组下标 >=0  , 不可能存在 j-nums[i] < 0
                        j-nums[i]的方案数 ， 和 nums[i] - j的方案数 是一样的。  只需要把 nums[i] - j的方案中所有符号逆置
                        就得到了 j-nums[i] ,所以方案数 是一样多的。

                



**01背包模板**
        dp定义： f[i][j] = max( f[i − 1][j], f[i − 1][j − w[i]] + v[i])
                 f[i][j]表示前i件物品放入一个容量为j的背包可以获得的最大价值
            **code**
                    ​for (int i = 1; i <= n; i++)
                        for (int j = V; j >= w[i]; j--)
                            f[j] = max(f[j], f[j - w[i]] + v[i]);
            **for**
                j:V 倒序的原因： f[i][j] 依赖于 f[i − 1][j − w[i]] 和 f[i − 1][j] 即ij依赖于上一行的左上部分，与本行无关。
                                假如，我们j:V正序计算，对j计算后会覆盖f[j], 对于 k > j 的位置  f[k]本来是依赖于上一行左上的，
                                则可能因为f[j]被本行覆盖，导致计算错误。
        初始化：    
                恰好装满(也即凑够k元问题)：f[0] = 0, f[1...V]= 负无穷
                最多装载(不要求装满)  ：f[0...V] = 0
                解释：初始化：也即初始化第0行，因为第1行依赖于第0行，那么我们要对第0行进行初始化。
                        1.恰好装满： 使用f[0][j]：表示前0个物品，放入容量为j的背包，恰好装满，可以装的最大价值。
                                    问题就是0个物品，对于容量大于0的背包，都不可能装满。所以对于j>0的状态都是未定义的状态。
                                    后序状态不可能由未定义状态转换而来。 所以为了确保 max选择时不会选到这些非法状态，
                                    讲 f[1...v] = 负无穷
                        2.最多装载: 不存在上述的非法状态， f[0][j]：表示前0个物品，放入容量为j的背包，不要求恰好装满，
                                    所以，没有这些非法状态，0个物品，最大价值就是0. 所以 全部赋值0即可。
                                      f[0...V] = 0
        总结： 
                1.滚动数组，倒着算。依赖上一行，不依赖本行
                2. 初始化，非法状态，要确保选不到。 
          
**完全背包**  有N种物品和一个容量为V的背包，每种物品都有无限件可用
            
        dp定义： f[i][j] = max( f[i − 1][ j], f[i][j − w[i]] + v[i])
                  f[i][j]表示前i件物品，可以重复选用的情况下，放入一个容量为j的背包可以获得的最大价值。
                  可以发现， 由01背包的f[i − 1][j − w[i]] + v[i] 变为了 f[i][j − w[i]] + v[i]
        **code**
                    for (int i = 1; i <= n; i++)
                        for (int j = w[i]; j <= V; j++)
                            f[j] = max(f[j], f[j - w[i]] + v[i]);
        **for:j**  :  j变为正序， 此时 f[j]将会依赖于本行左侧的元素。 本行左侧代表，可能已经选用物品i,现在重复选用。
        
        初始化：  同01背包一样。

**背包优化**
            1.若两件物品ij满足 w[i] <= w[j]且 v[i] >= v[j]，则将物品j去掉，不用考虑 o(n^2)
              属于贪心优化。






**LIS: 最长上升子序列**

**Q300**         最长递增子序列
                 tails[k] 的值代表 长度为k+1 子序列 的 最小 尾部 元素值。  
                 长度为k+1的子序列的最小尾部元素 必然 大于 > 长度为k的子序列的最小尾部元素。
                    int res = 0;  
                    // 对于每一个num 更新tails数组
                    for(int num : nums) {
                        // 在tails数组的 0~res之间二分查找 tails[k] >= num
                        // 找第一个大于等于num的位置。
                        int i = 0, j = res;   //  若存在则更新位置i ,若不存在，则i == res 更新的就是res 的位置。
                        while(i < j) {
                            int m = (i + j) / 2;
                            if(tails[m] < num) i = m + 1;  // m的位置小于num, 说明第一个大的一定在m的右侧。
                            else j = m;   // m的位置大于等于num  ，则第一个大的一定在左侧或则就是m. 
                            // 若m左侧元素都小于num,则最终一直更新i到现在j=m的位置。
                            // 若左侧元素等于num, 则j一直左移动，直到最左边等于num的位置。
                        } 
                        // 若不存在，则更新的是 tails[res] 下边会使得res+1.  
                        tails[i] = num;
                        // 若res == j 说明在 [0~res)中不存在 tails[k] > num 则序列长度+1.
                        if(res == j) res++;  // res == i也一样
                        // 这里有一个问题，就是该判断使得，该代码只能找 严格递增的，出现相等的，j的位置是在(0~res)之间，则res不会增加。
                    }

**Q334**        递增的三元子序列
                Q300的简化。k = 3即可。设一个dp[2]数组即可。当出现num>dp[1]时，dp[1]:说明现在已经有长度为2的子序列了。
                    而num>dp[1]说明，num不能更新dp[1],应该更新dp[2],说明存在长度为3的子序列了。而dp[2]不需要更新，直接返回true即可。
                        若一直无法更新dp[2]的位置，说明不存在长度为3的序列。


**Q338**       比特位计数  对于输入num,给出 0 <= i <= num的 每一个i的比特位数。
                        如 ：输入 5 返回 [0,1,1,2,1,2]
     **不好想到**        使用动态规划：  
                        原理： 10 : 1010  8 ： 1000   10的比特位数 恰好是 8的比特位数+1， 即差最后一位。
                        i&(i-1) ： 可以消去最后一位1，这样就可以通过10找到8. 
                        通过这样向前的依赖，就可以通过dp获得每一个数的比特位数。
                        for(int i = 1; i <= num; i++){
                            dp[i] = dp[i&(i-1)]+1;
                        }      
**Q354**        俄罗斯套娃信封问题
                说白了就是二维的LIS问题，即最长递增子序列。 但是由于二维问题。会互相牵制。
                1. 先将数组按照一个维度排序。比如按照w排序。那么直接找 h的最长递增子序列即可。
                问题：因为是二维的，如果只按照w排序， 那么w相同的情况下，如 2*3  2*4，那么使用过2*3后，34是递增的，
                会同时用到 2*3，和2*4，照成错误。按照我们的想法是，w相同的只能选一个，必然是选h最小的。
                2. 由上问题，我们在w排序的基础上，对h进行逆序排序。 即 2*4 在 2*3前边。 这样按照 二分的LIS算法，
                3小于4，那么同一个最短子序列就会最终使用 2*3将2*4覆盖掉。

**净胜分问题** 

**Q486** 预测赢家 ： 分数数组： [1, 5, 2] ab两人交替从数组两端选择一个拿走。 最终看a是否能胜利。
         使用动态规划，把问题规模缩小。  假设现有数组[a,...,z]玩家1先手。 那么玩家1可以选a或者z.
         于是问题被缩小为 选a剩下[b,...,z],或者 选z剩下[a,...,y] 
         引入 净胜分概念， 即玩家x先手在当前数组中可以获得的最大分数(玩家x获得分数 - 玩家y获得分数)
         设dp[i][j]: 表示: 玩家x先手在数组中可以获取到的净胜分。
         那么 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])    
            其中： dp[i + 1][j]：由于自己已经选择了i, 那么就相当于对手 在i+1到j是先手的。对手先手在i+1到j可以获得的最大净胜分。
            因为是对手获得的 净胜分，所以要用减法。
                    for (int j = 1; j < len; j++) {
                        for (int i = j - 1; i >= 0; i--) {
                            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
                        }
                    }
                注意计算顺序
    