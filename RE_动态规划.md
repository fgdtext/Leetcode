**Q10** ： 正则表达式匹配  MD:字符串
**Q5** ： 最长回文子串。 MD:字符串
**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。


**Q62**    不同路径
         **杨辉三角**      
            每个位置的路径总数 = 该位置左边的路径总数 + 该位置上边的路径总数
            其实就是爬楼梯题的变行，这个是二维的。


**Q64**     最小路径和
            还是动态规划
            这个和**Q62**的不同之处就是，上边是求总数，不需要左选择。
            相同点都是，左上角到右下角，只能2方向搜索。 这一点给了我们通过迭代dp的机会。
            假设该题是4方向的，起点和终点不是在角落，那么要迭代dp就不行了，因为填表顺序太复杂，各个方向都有依赖。但是可以通过递归记忆化来解决。递归记忆化就是为了解决这种计算顺序无法掌握的情况。
            该题在一点要做这样的选择 dp[i][j] = min(dp[i+1][j],dp[i][j+1])+m[i][j];
            不再是简单的求和。
**Q91**     解码方法  12335323131332 -> abaasdasd   数字到字符的映射。有多少种解码方法。
            其实就是爬楼梯 的改编。



**总共6题股票问题**
 **双dp问题**      money[i]: 第i天结束时，持有钱的数目。 hold[i]: 第i天结束时，持有股票的数目。
                   卖出：+prices[i]  ,买入：-prices[i]
       
**Q121**    买卖股票的最佳时机I  ：  **只能买入和卖出一次**。
            方法1 ：  使用滑动窗口， left < right, 然后left永远指向right之前的最小值。 只有在right遇到更小值时，left移动到right的位置。，这样就可以得到数组中，求得 num[right] - num[left]  的最大值。
            方式2 ： 动态规划，可以压缩到只使用常数个变量。 用不着。因为只能买入和卖出一次。
            
**Q122**    买卖股票的最佳时机 II  ： 必须卖出后，才能重新买入。 **可以多次买卖股票**
            **股票可以在同一天买入和卖出**
            贪心： 只要价格高于买入价格， 就卖掉。假设三天的价格是 7 8 9 买入7，卖出8，再买入8，卖出9 总差价就是2. 等价于7买入，9卖出。
            所以，只要今天比昨天高，就计入利润。
            使用动态规划也是可以的。

**Q123**    买卖股票的最佳时机 III  : **最多做两笔交易**
            **股票可以在同一天买入和卖出**  ： 
                    int buy1 = -prices[0], sell1 = 0;
                    int buy2 = -prices[0], sell2 = 0;
                    for (int i = 1; i < n; ++i) {
                        buy1 = Math.max(buy1, -prices[i]);
                        sell1 = Math.max(sell1, buy1 + prices[i]);
                        buy2 = Math.max(buy2, sell1 - prices[i]);
                        sell2 = Math.max(sell2, buy2 + prices[i]);
                    }
                    return sell2;
            在计算sell1的时候，为什么要使用刚刚更新过的buy1呢？？？这就是巧妙的地方，我们允许今天买入的股票，在今天卖出。
            在计算buy2的时候， 我们又使用刚更新过的sell1, 这就表明，我们今天卖出了， 但是还可以继续买入。
            sell2也是同理。
            那么最后我什么返回sell2呢？ 一定是做了两笔交易，才能取得最大利润吗?
            不： 得益于上边的设定， 我们总是能得到当天完成两笔交易时取得的最大利润。 因为我们能同一天，完成一笔不赔也不赚的交易。
            这就是，不设置冷冻期的好处。

**Q188**    买卖股票的最佳时机 IV ： **最多做K笔交易**
            Q123的增强。 变为buy[i], sell[i],即可


**Q714**     买卖股票的最佳时机含手续费  : 不限制交易次数，无冷冻期，有手续费。
             我们设定在卖出出，扣除手续费。
             这样这道题就和 **Q122** 一样了。

**Q309**     最佳买卖股票时机含冷冻期  ： 不限制交易次数，但是卖出股票后，无法在第二天买入。
            这题因该分3个状态：  1. 持有股票   2. 不持有股票，并且处于冷冻期的收益， 3.不持有股票，不在冷冻期的最大收益。
             f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - prices[i]);  // 要持有股票，只能是从已经持有股票，或者从不在冷冻期转来
             f[i][1] = f[i - 1][0] + prices[i]; // 如果今天处于冷冻期，说明是昨天卖了股票。
             f[i][2] = Math.max(f[i - 1][1], f[i - 1][2]); // 

**Q131**     分割回文串 : 对串分割，要求所有子串都是回文串，返回所有方案。
             1. 首先，我们通过dp获得所有子串是否是一个回文串。dp[i][j] = true 则子串ij为回文串。
             2. 通过回溯的 begin写法， 以当前位置为起点，准备分割下一个回文串。终点有很多选择。只要dp[i][j] = true即可。
             3. 当cur == len时，说明已经分割完毕。存入list即可。
