**Q32** . 最长有效括号 一个有效的字符串一定是 从左到右扩展的子串，都是满足 左括号数量 >= 右括号数量的。且该串本身 左括号数量 = 右括号数量
            使用dp[i][j] = k 表示 i~j的子串，k = 左括号-右括号数量。当k = -1时，表示i~j一定非法，且以i开头，jj>j的的其他串也都是非法的。
            k > 0 则表示后序还有可能是合法的。
            该方法是最只直观的方法。但是时间复杂度 o(n^2)太慢了。
        **双指针**      还是左括号数量m >= 右括号数量n的的，进行双向 遍历 出现m = n就保留最大， m < n就 mn置0.从下一个位置从新开始数。
                        反向再找一遍。
        **动态规划**    dp[i] = k : 表示以下标 i 字符结尾的最长有效括号的长度  
        **栈**       
                    这我想不到，这栈用的太骚了。
                    问题： 为什么要用 占位 不用行不行。对于 ()() 这样的例子，假如入栈，出栈，会得到2. 后边的实际是可以继续扩展的，但是由于我们已经全部出栈,会导致前边的丢失。
                    所以我们总是需要在出栈后，栈中永远保留，最长串的前一个位置。这样匹配出栈时，总是可以占位留在栈顶。


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。



**Q76**     最小覆盖子串  s = "ADOBECODEBANC", t = "ABC" ans = "BANC"  即BANC是一个最小子串，包含了 A,B,C三个字符。时间要求o(n)
            我觉的是一个双指针。
            right指针遇到不属于t的字母就不断扩张，遇到属于t的字母就停下，然后left收缩
            left收缩时，若指向属于t的字母，就判断去掉之后是否满足t的需要，满足就收缩，否则right继续扩张。ans在收缩后保留最小值。
    
**Q239**    滑动窗口最大值  [1,3,-1,-3,5,3,6,7], k = 3    输出：[3,3,5,5,6,7]  
             问题的关键是：若左端移出窗口，而他恰好是窗口内最大值。那么如何找到第二大的那个值。
             使用双端队列，的单调递减栈。若移出的元素不是队头那么直接删除即可，因为删除的不是窗口内最大值。
             若移出窗口元素是队头元素，说明删除元素是窗口内最大值。那么对头元素也要删除。然后以单调栈的方式把新元素加入队列尾部
             此时就可以确定新窗口的最大值，一定是队头。

**Q283**     移动零 把数组中的0移动到数组右侧，且不破坏非0元素的顺序。
            left指向永远指向当前数组第一个0的位置。 right指向left后第一个非0元素，然后交换。
            right再走向下一个非0元素，left走向下一个0.

