**Q31**  . 下一个排列 
        654321 ： 是最大排列
        146532 ： 是 14  开头的最大排列， 此时递增只能用6532中大于4的最小元素5开始 ： 15开头
        而15开头的最小字典序为 15 2346 . 即交换大于4的最小元素5与4的位置，然后后边构成递减序列，逆置该递减序列，即为最小字典序。


**39**  组合总和  无重复数组，数字可以重复选取，拼target,  结果不可重复。
        两种写法，对应两种递归树结构。2,3,6,7
        1. 对 cur 在cur层，直接对cur选多次(包括0次) ，第一层就是分为 对第一个数，选择次数的不同，归为不同分支。 
                第二层就是在选择第一个数的基础上，选择第二个数次数的不同，分为不同分支。按照cur的不同选择次数划分分支。
                     root
       ''          2         22    222    选2
      '' 3  33     23       223            选3
     ''  3                                  选6
    ''7                                      选7
        2. begin写法。规则是，第一层是从 0到end选不同的数，分不同的枝。 
                    root
                 2   3   6   7   root从0开始选
              22  23   3   6     
             223  23
        每个节点向下一个结点发展时， 他上次选择的最后一个位置就是下次选择的起始位置。

        这题两种写法都好实现，且复杂度一样、

**Q40**  . 组合总和 II  :   有重复元素数组， 每个数字只能选一次， 拼target, 结果不可重复。
            1. 每个元素分为选或者不选进行分支。 一层只指针cur一个元素，分两支。如果有两个2. 选第一个不选第二个， 和不选第一个选第二个
                    形成了重复。 这样就很难去重。选和不选其实就是上边的 选0次和选多次，不过这题规定最多一次。
            2. begin写法 + 同节点的子节点不用同元素， 每个节点向下一个结点发展时， 他上次选择的最后一个位置就是下次选择的起始位置。
                    当前层按照其实位置向后每一个可选元素进行分支。
            首先 我们分析重复的来源。 怎么产生的。 有两个 2  选第一个不选第二个， 和不选第一个选第二个形成了重复。
            345556
            对于一颗不限制选择的递归树   
                         root
                3    4    5         5      5       6  可以发现当前层在选择时，由于可以选择同结点同层已经选择过的数字
        34  35 36 。。。55 55 56  55 56    56          那么3个5后边的分支必然会存在重复。 
        于是改进一下   我们限制 同层已经用的数字不能再用。 但上层用过的数字不影响下层使用。
                    3       4     5      6
                34 35 36， 45 46，55 56                  只有 同一个结点的子节点不能使用相同的元素。
                这样就防止了重复。这样就可以保证  55 只在一处出现。
            
            为什么 ： 方式1，无法这样避免重复。？？？
                因为 ： 方式1的递归树是二分支的， 每一个分支都可能存在不重复和重复的，无法通过相似方式剪枝来完成避免。
            方法1如何避免重复 ： ？？？？？
                将相同y个x看做一个位置。  在同一个结点下，扩展多个子节点，分为选0次，选多次， 次数<y即可。
                    因为一次性选走了x , 每个分支都是不同的， 下一层不能再选x,因为x已经用光了。
                此时，该题就已经基本等价于 Q39的写法。

        
**Q46**       无重复元素的全排列  ： 不需要考虑去重。
              
