**Q94**     二叉树的中序遍历
**非递归**   递归算法就不说了， 主要是 ：非递归实现中序遍历
            1.若一个结点有左孩子,就一直把左孩子入栈.
            2.从栈中取出一个结点,访问, 然后若该结点有右孩子,就把右孩子入栈.若右孩子有左孩子,则同1.


**Q96**     不同的二叉搜索树 : 以 1 ... n 为节点组成的二叉搜索树有多少种？
            1. 有一个公式: 考研的时候学过(记错了).   此处错误 这个公式是n个数出栈和入栈的顺序有多少种: c(2n,n)/(n+1)
            2. 转化为线性dp问题. 即 123有几种,再加上一个4 又有几种.即我们直到了1个数有,2个数,3个数分别有多少种.那么4个数有多少种?
                4个数,选一个为root, 那么左侧0,右侧3,左侧1,右侧2.   左侧2,右侧1,左侧3,右侧0. 分为这些情况,全加一块即可.
                注意: 例如: 左侧分2,右侧分1, 左侧的种类m和右侧的种类n,是相乘的关系,
**Q98**     验证二叉搜索树  : 判定一个二叉搜索树是否合法.
            中序有序则合法.  使用全局的pre跟随指针.随着递归改变指向.作为前驱即可.

**Q99**     恢复二叉搜索树  : 二叉搜索树中两个结点被错误的交换,再不改变结构的情况下,恢复. 不改变结构:即树的分支情况不改变.
            如果使用中序有序,很容易发现两个点的位置不对. 于是可以通过时间o(n)空间o(n)的算法来完成. 但是这题要求不能使用额外空间.
 **空间o(1)**
 **hard**   1. Morris 遍历,不使用栈的遍历方式,叫啥来着,通过使用空闲指针,来完成中序遍历,那么也可以实现空间o(1)
 **放弃进阶**               但是该算法很难掌握.
            2. 失去额外空间, 我们就无法进行 常用的中序遍历.   所以这题,唯一使用空间o(1)的方法就是Morris遍历 


**Q101**     对称二叉树   从root处镜像对称
            这个题通过递归算写，还是蛮新的。 即同时对两颗树进行先序递归， 
            l.val == r.val
            pre(l.left,r.right) pre(l.right, r.left)

**Q106**     从后序与中序遍历序列构造二叉树
            1. 后序最后一个是root结点， 在中序中找到root结点的位置，划分为左右两侧序列。
            2. 构造出根据左右划分，将后序序列进行划分
            3. 构造出左右子树
            4. 连接到root上
            5. 返回root.


**Q107**    downToUp层次遍历：  先最后一层，向上。
            可以用dfs， dfs时根据层数，将元素加入到该层对应的列表中。


**Q109**   有序链表转换为平衡树
            进行递归的分治算法， 让如果当前结点是奇数，那么左右平分， 如果是偶数，那么永远让左侧少右侧一个。
            最后一定是平衡的。让左侧多也是可以的。
            可以使用中序遍历， 我们使用中序遍历构造左子树时，我们限制左子树的数量为当前剩余结点的一半。这样递归下去。总是可以保持左子树结点恰好是一半。这样就保持了平衡。



**Q116**    填充每个节点的下一个右侧节点指针 即树的结点多一个指针，是指向同层的下一个结点的。填充该指针。
**Q117**    prehead永远指向下一行第一个。 让cur指向prehead, prehead再指向下一行第一个，然后pre指向cur
            pre,cur伴随遍历该行，填充他们子节点的next指针。
            本质就是：使用上一层的next结点，  从逻辑结果来看，上一层的结构本质就是一个队列。


**Q124**     二叉树中的最大路径和
                 后序递归，向上返回下边可向上拼接的最大路径即可。 路径可能从当前结点开始，也可能包含左子树，也可能包含右子树，三选一。


**Q127**     单词接龙 ： 两个词只有一个位置不同，那么就是相邻点。
            求两个单词在图中的距离。即经过多少次变化可以到达终点词
            1. 层次遍历    ： 记录到达每个点的最短路径长度。
            优化建图， 如果我们拿出每两个结点，判断是否只差一个字符不同，那么效率太差了。
            加入start: tot  end: dat     列表有单词 hot,dot
            那么我们通过虚拟结点把所有结点连在一起。 
            tot- > *ot  t*t to*
            hot- > *ot  h*t ho*
            dot- > *ot  d*t do*
            dat- > *at  d*t da* 
            那么就有 tot- > *ot- >   dot- >   d*t- >dat 
            通过 map记录， *ot 的下标即可。