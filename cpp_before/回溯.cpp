#include <bits/stdc++.h>
using namespace std;



/**
 * 可重集的排列   ：  难点
 * 输入数组 p[]  ,输出A[]
 * 
 * 两个特殊序列的解决： 
 * 1：  111111111的排列可以出现。必须允许p[i]出现重复元素。
 *      只要 A[]中P[i] 出现的次数，小于在p[]中出现的次数，说明p中还有该元素可用。
 *      本质：该字母没有用完，可以继续用
 * 2： 11111111的排列只出现一次。 经过1之后，该排列会出现。但是，在每层循环时，当第一次有 A[cur] = p[i] 的递归时，
 *     会出现 A[cur] = p[i+1] 的递归。但是这两个的递归结果是相同的。所以一个位置，赋相同的值进行递归是无意义的。该值在
 *     cur递归一次就好(不是出现一次，因为，当前位置确定以后，其后的位置会递归出很多种)。
 *     解决：输入 p[]先 ******排序*******。 只要 p[i] != p[i-1].即之前没有出现过即可
 * 
 */

void perm02(int cur, int n, int *A, int *p);
void perm02(int cur, int n, int *A, int *p)
{
    if (cur == n)
    {
        for (int i = 0; i < n; ++i)
            printf("%d", A[i]);
        printf("\n");
    }
    else
        for (int i = 0; i < n; ++i)
            if (!i || p[i] != p[i - 1]) // i ==0 短路条件， p[]要先排序好
            {
                int ok = 1;
                int c1 = 0, c2 = 0;
                //对 p[i] 在两个数组中计数，如果没有使用完，则可以继续使用。
                for (int j = 0; j < cur; ++j)
                    if (A[j] == p[i])
                        ++c1;
                for (int j = 0; j < n; ++j)
                    if (p[j] == p[i])
                        ++c2;
                if (c1 >= c2)
                    ok = 0;
                if (ok)
                {
                    A[cur] = p[i];
                    perm02(cur + 1, n, A, p); ///递归调用。
                }
            }
}



/*
不重复子集   begin 写法的模板A[cur] 可以改为 List   重要
*/
/**
 * 子集生成
 * 生成 1-n 的全集
 * 通过解答树，来看，很简单。
 */
//增量法， 就是 begin 构造法。 避免将{1,2} 输出为 {1,2}和{2,1}
// 这里的 A[cur] 代表集合。cur 自增是为放下一个位置。

void subset01(int n, int *A, int cur)
{
    for (int i = 0; i < cur; ++i)    //   输出当前子集， 下边尝试 扩大该子集。
        printf("%d ", A[i]);
    printf("\n");
    //若当前是0位置，则当前位置最小是 0 最大到 n。 否则，A中的元素，靠后的编号一定大于前一个。
    //集合后一个编号一定比前一个大。如果不在第一个位置，那必定不是0， 而是必须大于前一个。
    int s = cur ? A[cur - 1] + 1 : 0;
    for (int i = s; i < n; ++i)
    {
        A[cur] = i;
        subset01(n, A, cur + 1);
    }
}



// 位向量法  时间 > 增量法  增量法， 不用到 n就可以输出。
// 这个方法是最容易想到的。 但是有些问题，标记法，可能无法解决重复问题。
vector<set<int> > A;
void subset02(int *B, int cur, int n)
{
    int k = 0;
    if (cur == n)
    {
        set<int> s;
        for (int i = 0; i < n; ++i)
            if (B[i])
                s.insert(i);
        A.push_back(s);
        return;
    }
    // B对应序列的每一位，B[i] 为1， 则i 就在集合中，所以i 在集合中就两种情况，在或者不在。。
    B[cur] = 1;
    subset02(B, cur + 1, n);
    B[cur] = 0;
    subset02(B, cur + 1, n);
}

// 二进制法
void subset03()
{
    int n = 10;
    for (int i = 0; i < (1 << n); i++) //  (1 << 8) == 1 0000 0000
        for (int j = 0; j < n; j++)    // j表示确定第几个数。j = 1;
        {                              //j = 1; 则 1 << j == 10; i & 10 若 i的后第二位是 1,则 i & (1 << j) == 1 .
                                       // 通过移位 唯一的1. 来扫描 i 的每一位是否是 1 .是 1 ，则打印该位置。
            if (i & (1 << j))
                printf("%d", j);
        }
}


/*
 * 二进制知识： 使用s: 11100111来表示一个集合，初始用 L = (S-1)&S 来表示左集合，R = S^L 表示右集合。
 *             然后 L = (L-1)&S R = S^L表示。 
 *  由与运算性质：S中为 0 的位置， L中也一定为通过对L递减，则L可以表示S中所有的子集(即每一位‘1’都有出现或者不出现两种可能)。
 * 所以通过这种方式， L能取到S的所有子集，R通过取补集。就可以将一个节点的集合划分为左右集合。
 * 
 * 
 */




// 隐式图问题  
/**
 * 隐式图 路径寻找 ： 八数码问题 类似(6-14Abbott的复仇) 原图不是我们要遍历的图，原图只是定义了，方向和运行规则。
 * 要将隐式图，转换为 ，状态图。  这两题的差异： 复仇是在原图上行走，以不同方向到达一个点标识一个状态。
 * 而本题，使用图的数字的不同变换标识一个图的状态。
 * 
 * 本题总结： 1. 隐式图提取状态，隐式图，并不是一开始就给一张图，去遍历，。 而是在程序中动态的生成了一张图，以状态的迁移来标识一张图。
 *            2 状态(数组判重) 
 */





/*
问题描述 ： 九宫格 有八个格子有数字， 
2 6 4            8 1 5
1 3 7  ----》    7 3 6
— 5 8            4 — 2
通过移动 数字到空白处，将九宫格移动到 状态2.

这不是一个表面看上去的图。 而是应该通过定义，来描述一个。
定义  264137_58  为一个状态。  8157364_2  为另一个状态。 那么这两个状态就是新图的两个点。
从状态1， 变化到 状态2， 就是图中 点1，到点2的距离。


将一个数组表示为一个状态。 数组完全相同，则状态相同，表示同一个点。
那么如何快速证明两个数组完全相同呢。？？？？？

通过自定义类 Node 包装 数组，然后重写 Node的 hashcode 和 equals 方法。
hashcode 方法，仿造 String 类的hashcode 算法。效果最好。

(紫书中是手写的， 子索引hash表，太难记忆。放弃，改用java的api 来做。)

然后整体的算法就是BFS找最短路径。BFS最先扫描到 终点。那么BFS层数就是要移动的步骤。
*/


//  迭代加深搜索
/*
讲以下思想好了 ： 
设深度上限为maxd, 当前结点n的深度为 g(n) , 乐观估计函数h(n) 则当 g(n)+h(n) > maxd 的时候应该剪枝。

即，我们直到最大深度， 我们还知道我们至少还要多少层才能得出答案。
比如我们要使得递归和 > x, 目前得到的和是 cursum , 由于数据的特点，我们估计 最少要 h层之后，才能达到x.

由于 cur + h > maxd 所以当前路径不可能有解，直接剪枝。

*/