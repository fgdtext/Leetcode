**Q5** ： 最长回文子串。
            动态规划 ： boolean[][] dp = new boolean[n][n]; dp[i][j]: i~j是否是回文子串。 
            中心扩散法 ：每一个回文串的中心都是 一个字母，或者两个字母。我们枚举每一个这样的中心。对其进行扩展。
                        我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度  
                        长度为 1 和 2 的回文中心分别有 n 和 n-1 个  
            KMP : 模板匹配。s(j) : 作为p模式串，对s反转 s_rev(i):作为主串。 在kmp中while(i < s_rev.length()) 
                        则最后kmp将会匹配s_rev的最长后缀。 
                        正常kmp 都是p较短，则当出现 while (i < ts.length() && j < ps.length())  j ==  ps.length()时，则说明已经找到了p串
                        而该题 我们缺失了 j < p.length()的条件，只有i越界时才会停止，所以匹配的是后最。
                        当在找p前缀时，后缀时，由于i一直不停止，则即使在s中间找到了p串的前缀也不会停止匹配，而是继续向后匹配，
                        所以最后匹配的一定是 后缀，而不是中间的一部分。

                        当我们找到了p串的一个前缀是s串的后缀，那么该前缀就是一个回文串。 然后我们将s串删除最后一个字符，p串从begin开始匹配。那么我们就能找到第二个前缀作为s串的后缀。然后两个串取最长。以此类推。
                        其实，这样找就是，找以 begin开头的回文串的最长长度。 每找一个前缀，begin后移一个。

**Q10** ： 正则表达式匹配
        dp :  考虑*号的后效性，如从左向右匹配，那么*号到底吃多少个，是很难确定的。
            "aaa"
            "ab*a*c*a"  第二个a*，应该吃几个a是不确定的，因为后边还有一个a是必须吃一个，所以第二个a*吃几个a是无法确定的。
            所以，我们我们应该从右向左进行匹配，来消除这种后效性。

        nfa : 太难了。 不看了。


**Q31**  . 下一个排列 
        654321 ： 是最大排列
        146532 ： 是 14  开头的最大排列， 此时递增只能用6532中大于4的最小元素5开始 ： 15开头
        而15开头的最小字典序为 15 2346 . 即交换大于4的最小元素5与4的位置，然后后边构成递减序列，逆置该递减序列，即为最小字典序。

**Q43**  . 字符串相乘   ： 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积
                方法：  竖式。      
                     12345
                       567
                ----------------------
                        35                用7 乘每一位，加在res的对应位置上 上
                       28
                      21
                     14
                     7
                ---------------------
                       30                用 6 
                      24
                     18
                    12
                    6
                --------------------
                      25
                     20
                    15
                   10
                   5
                ----------------------
            res:
            每得到一个数，就可以确定res的一位，并向前一位进位，例如35，就可以确定5，并将3作为进位提前复制给res,在得到28时，28+3 = 31 确定1，进位3.