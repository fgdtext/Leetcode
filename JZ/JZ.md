JZ35 : **逆序对** **归并排序**

    在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

    使用 **归并排序**。 使用单调栈是不行的。

    
JZ19 ： 顺时针打印矩阵

JZ25 :  **复杂链表的复制**  带有random指针的链表的 深拷贝。 next指针一定是连续的。
        1. 先将链表的next进行复制。 12345 ->  1122334455 复制结点接在后边。
        2. 复制random指针的指向。 若一个结点的random指向3，那么其copy结点的radom就指向
            第二个3. 即第一个3后边的那个3.
        3. 链表分离。 


JZ33 : **丑数**  **动态规划**
        这道题目自己是有思路的，丑数能够分解成2^x3^y5^z,
        所以只需要把得到的丑数不断地乘以2、3、5之后并放入他们应该放置的位置即可，
        而此题的难点就在于如何有序的放在合适的位置。
        1乘以 （2、3、5）=2、3、5；2乘以（2、3、5）=4、6、10；3乘以（2、3、5）=6,9,15；5乘以（2、3、5）=10、15、25；
        从这里我们可以看到如果不加策略地添加丑数是会有重复并且无序，
        而在2x，3y，5z中，如果x=y=z那么最小丑数一定是乘以2的，但关键是有可能存在x》y》z的情况，所以我们要维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，然后当其被选为新的最小值后，要把相应的指针+1；因为这个指针会逐渐遍历整个数组，因此最终数组中的每一个值都会被乘以2、乘以3、乘以5，也就是实现了我们最开始的想法，只不过不是同时成乘以2、3、5，而是在需要的时候乘以2、3、5.

        dp[i] = min(dp[i2]*2, dp[i3]*3, dp[i5]*5)
        假设dp[i3]*3最小  那么   dp[i] = dp[i3]*3  而此时 dp[i2]*2 > dp[i]    dp[i5]*5 > dp[i]
        这样i2,i5指针就不需要移动，由他们得到的dp[i+1]仍然大于dp[i]。  而dp[i] = dp[i3]*3  此时 i3就需要右移一位。
        

JZ17 : 二叉树的子结构 ： 判断B树是否是A树的的一部分。(B)是一颗完整的树

        就是对A的每一个结点去判断是否是B的根。时间就是 o(m*n)

JZ23  : 给出一个后序序列，判断是否是二叉搜索树的 后序遍历。

        二分： 后序最后一个是root.   那么前半段都有 val < root.val    后半段都有 val > root.val 
        然后递归去判断。 时间 o(nlgn)
        代码很好写的了。 

JZ59   : Z字形 层次遍历 二叉树。 利用双端队列 + flag 切换出队方向，和入队时的左右子树顺序。

JZ32  : 输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
                必然要排序的，到底哪个排在前边。 通过比较 s1+s2 : s2+s1 比较字典序。 哪个字典序小，哪个在前。
                重写比较器即可。


