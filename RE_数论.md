**Q29**    不使用 */% 两数相除  只能只用int
            数论题： 假设  a/b > 1 否则 ans=0
                    若 a > 2*b  则 a/b > 2*b /b = 2*1 同理
                    若 a > 2*2*b 则  a/b > 2*2=4;
                    若 a < 2*2*2*b 则 a/b < 2*2*2 = 8;
                    说明 4 < a/b < 8;
                    a/b = (a-4*b)/b + 4    假设 c = a-4*b  则有  a/b = c/b +4;  b < c < a  这样就可以不断的缩小a。
                    另外，由于负数最小值容易造成越界，我们将两个数都先变为负数计算。最后再转回来

**Q89**     格雷编码
                二进制转 格雷码   二进制：格雷码   =     i :  i^(i>>1)
                格雷码转 二进制   ： 最高位相同。 B[i-1] = G[i-1]^B[i]  :所以要对二进制先求高位。然后递归的去求低位。



**Q136**      只出现一次的数字 ： 只有一个数只出现一次，其余数都出现两次。
              用亦或运算  a^a = 0.  亦或运算可以做交换率， a^b^c^a^d^b^c = a^a^b^b^c^c^d = d 


**Q166**      分数到小数 numerator = 2, denominator = 3 输出 "0.(6)" 表示6循环。
                numerator = 1, denominator = 2 输出 "0.5"
                难点其实就是对小数部分的处理。我们可以模拟除法的执行。 当被除数小于 除数时，被被除数*10， 然后再求商追加到小数。
                对循环小数的处理，例如， 1/3  整数部分得到0 然后1*10 = 10 ， 10/3 = 3,第一个小数就是3.余数为1，这个1已经出现过了。
                说明出现了循环小数。循环的部分就是上次出现1的位置到现在的位置。


**Q190**       颠倒二进制位  颠倒给定的 32 位无符号整数的二进制位。 11110000 - >  00001111
                假设是8位的数字  abcd efgh 最终应变为 hgfe dcba
                abcdefgh -> efgh abcd  前4位和后四位互换，通过左移四位，右移四位然后 |再拼接在一起。
                efgh abcd -> gh ef cd ab  对4位中前后两位，互换。
                gh ef cd ab -> h g f e d c b a  对2位中前后1位互换。 结束。
                        n = (n >> 16) | (n << 16);
                        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
                        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
                        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
                        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);


**Q191**        位1的个数  ： int数字中，1的个数。负数由补码表示，位1也是补码的位数
                不断把数字最后一个 1 反转， 将 n 和 n-1做 **与运算** 会将最低位的 1 变成 0
                        int count = 0;
                        for(; n!=0; ++count){
                            n &= n-1;  // 会将n的最后一个1变为0
                        }
**Q201**        数字范围按位与两个整数 left 和 right  ans = right&(right-1)&...&(left)
                        while (m < n) {
                                // 抹去最右边的 1
                                n = n & (n - 1);
                        }
                        return n;
                 保留left和right二进制位的公共前缀。即为答案。因为
                 1110100
                 .....
                 1111111
                 ans = 1110000
                 从0100 -> 1111  全部与运算结果一定为0. 因为011 -> 100 进位，后两位一定结果是0， 最高位也有0， 所以结果为0.
                 
**Q204**         计数质数
                 埃式筛选法 当下标来到3, 那么把3的所有倍数位置全部设置为true(是合数). 
                 遇到k为true就不需要去设置k的倍数，因为k的倍数，一定也是设置k为true的那个数的倍数。
                 最小从i的两倍数开始。
                 需要一个数组。
                 时间 稍微大于 > o(n),空间o(n)

**Q279**         完全平方数 13 = 9 + 4  用最少的完全平方数使得其和为 n。
                 这是一个数论问题，但是数论解法太高深了，看不懂。 所以看作背包问题比较好。
                  dp[i] = Math.min(dp[i], dp[i - k*k]+1);
                 
**Q292**        Nim 游戏   return  (n%4 != 0);
                        当给对手留下4块石头时， 自己肯定能获胜。但是如何给对手留下4块呢。
                        我们反着想，如果对手给我们留下4块，那么我们必然会输。这么想就方便了。
                        假设有n个，且n%4==0,即n是4的倍数。
                        由于我们先手只能拿 1,2,3.  那么对手对应总是可以拿 3,2,1. 这样一轮下来，就是n-4,仍然是4的倍数。
                        这样到最后，必然是我们输。

                        若n不是4的倍数，那么我们起手就可以拿1,2,3剩余m个， 此时m是4的倍数。那么对手就必输。