**Q4** : 寻找两个正序数组的中位数     转换为找 **有序** 数组第 K 小的问题。 每次在上下数组找 k/2的位置，比较大小，小的数组左侧都可以被抛弃。
                                然后找第 k-(j-start+1) 小即可。直到找第1小。即最小值即可。 



**Q15**  : 三数之和    两数之和可以用hashmap来解决。但是三数之和，就不行。 还有一个想法是通过 回溯法，但是去重比较困难，而且比较耗时
                  采用先排序，  然后 基准线 + 双指针法。(三指针) i:a 在i右侧使用双指针，分别是b,c 若a > 0,则右侧一定找不到合适的bc.所以要求a<=0
                  由于要去重，对于一对可行的bc使用后，要将left,right向内自动，直到b不是原来的b，c不是原来的c，或者left>right 
                  若对于 当前bc,a+b+c < 0 那么说明b小了， 因为更大的c已经使用过了，此时只能增加b.


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。



**Q134**     加油站
                第一次写出来了，而且分析和代码写的都很好。第二次就然没写出来。
                数组题：前缀和。。很重要。说了多少遍了。
                gas  = [1,2,3,4,5]
                cost = [3,4,5,1,2]
                差数组： -2 -2 -2 3 3
                方法1(自己写的方法) 首先先不考虑循环的问题。 我们先猜测前缀和最小位置的下一个位置是起始点。
                首先是 最小前缀和的性质，假设最小前缀和的位置是 i, 那么一定存在j < i ,j到i的后一定小于0, 因为若其大于0，那么j才是最小前缀和。 而且由于i处是最小前缀和，那么i到k i < k，k是任意的i到end中间的一个数。  这个和 一定 > 0,否则i就不是最小。

                所以，当找到最小前缀和位置i, 那么从i+1,一定能走到end,  例如 2,2,-2,(-2),3,3,-3,-3
                最小前缀和是第二个 -2的位置。 那么从3出发，走到end时油箱还有3，从-3走到第一个2，耗费最后的3个油。
                最小前缀和之后的半个数组，可以通过化简   得到一个大于等于0的数，数组可以化简得到 2,2,-2,(-2),0.
                也就是说从0出发，到第一个2的结余是0， 这个数是大于等于0的。所以只要整个数组是大于等于0就必然存在答案。


**Q135**     分发糖果  ： 每个孩子至少一个糖果，评分更高的孩子必须获得的更多。 最少发糖数
                        例如 评分121， 那么第二个要比两侧多，应该121发5颗糖，若是 评分122，应该发 121， 第三个孩子并不比左右孩子评分高。例如评分：1221， 那么久该发1221， 
            这个题举个例子很容易搞明白，我们先考虑递增序列， 1234555， 只需要第一个发1个，然后后边到5发5个依次递增，第二个和第三个5只发1个。所以递增序列就是记住上一个发了pre，如果当前评分大于前一个那么就发pre+1, 如果等于就发1。然后更新pre。
            对于递减序列: 1，2， 7，6，5，4，3    通过递增计算知道，前三个发糖 1，2，3
                         1，2， 3   . 。 然后6发现递减了，于是对6发一颗糖。发糖数 k = 1
                         1，2， 3，1    5也是递减，那么就对 6和5都发一颗糖，发糖数 k = 2
                         1，2， 3，2，1  同理，遇到4，对654共发出 k=3课糖。
                         1，2   3，3，2，1  . 现在发现了错误， 7>6 那么7发的糖数应该大于6.所以发糖错误。
                         当k = top处发糖的个数时，应该对top出也多发出一颗糖。也就是 k=3,不仅对654发，还要对7发。让k多做一次++即可。
                         1，2， 4，3，2，1      我们只需要记录 7处本来发了多少（3）， 随着递减对k++，当k= 3时，多做一次++。即可。
                        递增区域，除了山峰top，发糖数从1做递增，当出现k=top时，那么就要对山峰的糖数做出补偿。



**Q162**    寻找峰值  假设 位置-1和len的大小是负无穷 。最简单的做法就是 遍历一遍，第一个和最后一个特殊处理，即可。但是本题要求时间o(lgn)
                    while (l < r) {
                        int mid = (l + r) / 2;
                        if (nums[mid] > nums[mid + 1])
                            r = mid;// mid位置就可能时山峰。在左侧
                        else
                            l = mid + 1; // mid+1的位置就可能是山峰，在右侧。
                    }



**Q164**    最大间距  : 给定一个无序的数组(非负)，找出数组在排序之后，相邻元素之间最大的差值。要求时间空间o(n)
            使用平均间距桶排序 我们可以肯定， 假设数组最大值最小值为 max，min,  那么每两个相邻的数之间的平均间距为 d = (max-min)/(n-1)
            那么由平均数原理，最大间距， dmax >= d 必成立。
            所以我们把x坐标，划分为 d大小的桶。 然后遍历每一个数，看其落在哪个桶内。而桶只保存桶内的最大最小值。
            为什么桶内其他值可以被抛弃，因为桶内的两个点的距离一定 < d  . 所以桶内只存最大最小值。
            那么相邻两个桶的距离的最大值就是 ans.



**Q189**    旋转数组  空间要求 o(1)  
                    使用三次 reverse()函数即可。左侧一次，右侧一次，全局一次。


**Q238**    除自身以外数组的乘积 只能使用 ans一个数组和给出的num数组。不能使用其他额外空间。
            使用 ans数组先记录ans[i] = 前i-1个数的乘积。
            然后对ans从右往左算。ans[len-1]是正确的。 。使用R记录当前右侧所有数字的乘积。R = 1
            所以 ans[len-1] = ans[len-1] * R  R = R*num[len-1] 依次类推。



**Q239**    滑动窗口最大值  [1,3,-1,-3,5,3,6,7], k = 3    输出：[3,3,5,5,6,7]  
             问题的关键是：若左端移出窗口，而他恰好是窗口内最大值。那么如何找到第二大的那个值。
             使用双端队列，的单调递减栈。若移出的元素不是队头那么直接删除即可，因为删除的不是窗口内最大值。
             若移出窗口元素是队头元素，说明删除元素是窗口内最大值。那么对头元素也要删除。然后以单调栈的方式把新元素加入队列尾部
             此时就可以确定新窗口的最大值，一定是队头。
            
            
**Q287**     寻找重复数 长度为n+1的数组，元素为 1~n  ,假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。必有重复。要求不改变数组
              1. 桶归位。 若num[0] != 0(因为没有0，所以肯定不等，必有num[0] = k), 
                                    若k != num[k],则交换num[0] 和num[k]。这样元素k就归位了。
                        这样不好，原数组发生了改变
              2. **Q142**，等价于在 链表中，找循环部分开始的第一个结点。
                 对于数组 1 3 4 2 2   其实可以看作是一个链表。有5个结点。
                 结点0 - > 结点1
                 结点1 - > 结点3
                 结点2 - > 结点4
                 结点3 - > 结点2
                 结点4 - > 结点2   
                 存在
                 使用快慢指针来跑。 slow：fast：下标
                 slow = nums[slow] : slow走向下一个结点，slow是下一个结点的下标。
                 fast = nums[nums[fast]] ： 一次走两个结点。

**Q324**       摆动排序 II  重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序
 **真hard**    
             1. 最容易想到的就是先排序，然后，从右半段逆序和前半段合并。
                比如： 1,5,1,1,6,4 -> 1 1 1 4 5 6  -> 1 6 1 5 1 4
                1,3,2,2,3,1 -> 1 1 2 2 3 3 -> 1 3 1 3 2 2  出现了错误。 本意是为了凸显先后的差
                导致靠近数组中线两侧的 2 在合并时相遇。如果 后半段不逆序。那么 就是  1 1 2  2 3 3合并。2和2就不会相遇
                1 1 2 | 2 3 3 -> 1 2 1 3 2 3 ok
             2. 针对1进行优化，首先为什么要排序？？。排序是为了划分数组，一侧小，一侧大。
                 优化：首先求出中位数。中位数target两侧元素数量一样多。通过求第k小求出中位数。
                      然后按照三国国旗划分法，把小于target的集中到左侧，大于target集中到右侧，等于target的位于中间。
                      该算法也叫：three-way-partition算法。
                      然后化为左侧，和右侧。进行交替合并。左侧元素个数>+右侧元素
                      为什么前后不排序，也可以合并。只要后半段是大于target的即可。


