**Q4** : 寻找两个正序数组的中位数     转换为找 **有序** 数组第 K 小的问题。 每次在上下数组找 k/2的位置，比较大小，小的数组左侧都可以被抛弃。
                                然后找第 k-(j-start+1) 小即可。直到找第1小。即最小值即可。 



**Q15**  : 三数之和    两数之和可以用hashmap来解决。但是三数之和，就不行。 还有一个想法是通过 回溯法，但是去重比较困难，而且比较耗时
                  采用先排序，  然后 基准线 + 双指针法。(三指针) i:a 在i右侧使用双指针，分别是b,c 若a > 0,则右侧一定找不到合适的bc.所以要求a<=0
                  由于要去重，对于一对可行的bc使用后，要将left,right向内自动，直到b不是原来的b，c不是原来的c，或者left>right 
                  若对于 当前bc,a+b+c < 0 那么说明b小了， 因为更大的c已经使用过了，此时只能增加b.


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。
