**Q4** : 寻找两个正序数组的中位数     转换为找 **有序** 数组第 K 小的问题。 每次在上下数组找 k/2的位置，比较大小，小的数组左侧都可以被抛弃。
                                然后找第 k-(j-start+1) 小即可。直到找第1小。即最小值即可。 



**Q15**  : 三数之和    两数之和可以用hashmap来解决。但是三数之和，就不行。 还有一个想法是通过 回溯法，但是去重比较困难，而且比较耗时
                  采用先排序，  然后 基准线 + 双指针法。(三指针) i:a 在i右侧使用双指针，分别是b,c 若a > 0,则右侧一定找不到合适的bc.所以要求a<=0
                  由于要去重，对于一对可行的bc使用后，要将left,right向内自动，直到b不是原来的b，c不是原来的c，或者left>right 
                  若对于 当前bc,a+b+c < 0 那么说明b小了， 因为更大的c已经使用过了，此时只能增加b.


**Q53**     **最大子序和**   :  很心痛的一道题
            每次看到就想取求前缀和数组。然后求最大差。但其实有更好的办法。
            1. 动态规划 ：f(i) : 以ai结尾的最大子序和。  f(i) = max(f(i-1)+ai, ai); 然后dp压缩，空间使用o(0) 
            2. 滑动窗口 ： 假设当前窗口和为sum, 最终结果为ans, 若当前sum <= 0 则如果对其继续扩张，sum对后边反而是负担，不会有贡献。
                            所以舍弃该窗口，然后sum = ai, ans = max(ans,sum) 只有当sum > 0 时对sum扩张才有意义。
                    如何舍弃已有窗口：　看贡献值。　贡献值是一个很常用的窗口收缩策略。



**Q134**     加油站
                第一次写出来了，而且分析和代码写的都很好。第二次就然没写出来。
                数组题：前缀和。。很重要。说了多少遍了。
                gas  = [1,2,3,4,5]
                cost = [3,4,5,1,2]
                差数组： -2 -2 -2 3 3
                方法1(自己写的方法) 首先先不考虑循环的问题。 我们先猜测前缀和最小位置的下一个位置是起始点。
                首先是 最小前缀和的性质，假设最小前缀和的位置是 i, 那么一定存在j < i ,j到i的后一定小于0, 因为若其大于0，那么j才是最小前缀和。 而且由于i处是最小前缀和，那么i到k i < k，k是任意的i到end中间的一个数。  这个和 一定 > 0,否则i就不是最小。

                所以，当找到最小前缀和位置i, 那么从i+1,一定能走到end,  例如 2,2,-2,(-2),3,3,-3,-3
                最小前缀和是第二个 -2的位置。 那么从3出发，走到end时油箱还有3，从-3走到第一个2，耗费最后的3个油。
                最小前缀和之后的半个数组，可以通过化简   得到一个大于等于0的数，数组可以化简得到 2,2,-2,(-2),0.
                也就是说从0出发，到第一个2的结余是0， 这个数是大于等于0的。所以只要整个数组是大于等于0就必然存在答案。


**Q135**     分发糖果  ： 每个孩子至少一个糖果，评分更高的孩子必须获得的更多。 最少发糖数
                        例如 评分121， 那么第二个要比两侧多，应该121发5颗糖，若是 评分122，应该发 121， 第三个孩子并不比左右孩子评分高。例如评分：1221， 那么久该发1221， 
            这个题举个例子很容易搞明白，我们先考虑递增序列， 1234555， 只需要第一个发1个，然后后边到5发5个依次递增，第二个和第三个5只发1个。所以递增序列就是记住上一个发了pre，如果当前评分大于前一个那么就发pre+1, 如果等于就发1。然后更新pre。
            对于递减序列: 1，2， 7，6，5，4，3    通过递增计算知道，前三个发糖 1，2，3
                         1，2， 3   . 。 然后6发现递减了，于是对6发一颗糖。发糖数 k = 1
                         1，2， 3，1    5也是递减，那么就对 6和5都发一颗糖，发糖数 k = 2
                         1，2， 3，2，1  同理，遇到4，对654共发出 k=3课糖。
                         1，2   3，3，2，1  . 现在发现了错误， 7>6 那么7发的糖数应该大于6.所以发糖错误。
                         当k = top处发糖的个数时，应该对top出也多发出一颗糖。也就是 k=3,不仅对654发，还要对7发。让k多做一次++即可。
                         1，2， 4，3，2，1      我们只需要记录 7处本来发了多少（3）， 随着递减对k++，当k= 3时，多做一次++。即可。
                        递增区域，除了山峰top，发糖数从1做递增，当出现k=top时，那么就要对山峰的糖数做出补偿。



**Q162**    寻找峰值  假设 位置-1和len的大小是负无穷 。最简单的做法就是 遍历一遍，第一个和最后一个特殊处理，即可。但是本题要求时间o(lgn)
                    while (l < r) {
                        int mid = (l + r) / 2;
                        if (nums[mid] > nums[mid + 1])
                            r = mid;// mid位置就可能时山峰。在左侧
                        else
                            l = mid + 1; // mid+1的位置就可能是山峰，在右侧。
                    }



**Q164**    最大间距  : 给定一个无序的数组(非负)，找出数组在排序之后，相邻元素之间最大的差值。要求时间空间o(n)
            使用平均间距桶排序 我们可以肯定， 假设数组最大值最小值为 max，min,  那么每两个相邻的数之间的平均间距为 d = (max-min)/(n-1)
            那么由平均数原理，最大间距， dmax >= d 必成立。
            所以我们把x坐标，划分为 d大小的桶。 然后遍历每一个数，看其落在哪个桶内。而桶只保存桶内的最大最小值。
            为什么桶内其他值可以被抛弃，因为桶内的两个点的距离一定 < d  . 所以桶内只存最大最小值。
            那么相邻两个桶的距离的最大值就是 ans.



**Q189**    旋转数组  空间要求 o(1)  
                    使用三次 reverse()函数即可。左侧一次，右侧一次，全局一次。


**Q238**    除自身以外数组的乘积 只能使用 ans一个数组和给出的num数组。不能使用其他额外空间。
            使用 ans数组先记录ans[i] = 前i-1个数的乘积。
            然后对ans从右往左算。ans[len-1]是正确的。 。使用R记录当前右侧所有数字的乘积。R = 1
            所以 ans[len-1] = ans[len-1] * R  R = R*num[len-1] 依次类推。


**窗口内删除最大值，后o(1)找第二大**   **双端队列，的单调递减栈：用于找第二大，递增栈用于找第二小** 
**Q239**    滑动窗口最大值  [1,3,-1,-3,5,3,6,7], k = 3    输出：[3,3,5,5,6,7]  
             问题的关键是：若左端移出窗口，而他恰好是窗口内最大值。那么如何找到第二大的那个值。
             使用双端队列，的单调递减栈。若移出的元素不是队头那么直接删除即可，因为删除的不是窗口内最大值。
             若移出窗口元素是队头元素，说明删除元素是窗口内最大值。那么对头元素也要删除。然后以单调栈的方式把新元素加入队列尾部
             此时就可以确定新窗口的最大值，一定是队头。
            
            
**Q287**     寻找重复数 长度为n+1的数组，元素为 1~n  ,假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。必有重复。要求不改变数组
              1. 桶归位。 若num[0] != 0(因为没有0，所以肯定不等，必有num[0] = k), 
                                    若k != num[k],则交换num[0] 和num[k]。这样元素k就归位了。
                        这样不好，原数组发生了改变
              2. **Q142**，等价于在 链表中，找循环部分开始的第一个结点。
                 对于数组 1 3 4 2 2   其实可以看作是一个链表。有5个结点。
                 结点0 - > 结点1
                 结点1 - > 结点3
                 结点2 - > 结点4
                 结点3 - > 结点2
                 结点4 - > 结点2   
                 存在
                 使用快慢指针来跑。 slow：fast：下标
                 slow = nums[slow] : slow走向下一个结点，slow是下一个结点的下标。
                 fast = nums[nums[fast]] ： 一次走两个结点。

**Q324**       摆动排序 II  重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序
 **真hard**    
             1. 最容易想到的就是先排序，然后，从右半段逆序和前半段合并。
                比如： 1,5,1,1,6,4 -> 1 1 1 4 5 6  -> 1 6 1 5 1 4
                1,3,2,2,3,1 -> 1 1 2 2 3 3 -> 1 3 1 3 2 2  出现了错误。 本意是为了凸显先后的差
                导致靠近数组中线两侧的 2 在合并时相遇。如果 后半段不逆序。那么 就是  1 1 2  2 3 3合并。2和2就不会相遇
                1 1 2 | 2 3 3 -> 1 2 1 3 2 3 ok
             2. 针对1进行优化，首先为什么要排序？？。排序是为了划分数组，一侧小，一侧大。
                 优化：首先求出中位数。中位数target两侧元素数量一样多。通过求第k小求出中位数。
                      然后按照三国国旗划分法，把小于target的集中到左侧，大于target集中到右侧，等于target的位于中间。
                      该算法也叫：three-way-partition算法。
                      然后化为左侧，和右侧。进行交替合并。左侧元素个数>+右侧元素
                      为什么前后不排序，也可以合并。只要后半段是大于target的即可。


**Q454**       四数相加 II  四个等长数组， i,j,k,l .使得 A[i] + B[j] + C[k] + D[l] = 0
                分析： 总共有 n^4种组合。 可以将复杂度降到 n^2. 
                1. 在mapAB中存，每一个ai+bj 的数量。
                2. 使用双层for，在map中找 -ck-dl 的数量count。 ans+= count.

**Q480**       滑动窗口中位数 ： 平衡树的root顶点恰好是中位数。但是实际的平衡树不好实现。
                因此使用  **双优先队列+延迟删除+平衡因子** 的做法
                small：大顶堆 , 堆中元素是窗口内较小的一部分。
                big  : 小顶堆 , 堆中元素是窗口内较大的一部分。
                balance :  samll堆比big堆多出几个元素。 balance只能等于0，或者1. 表示两个堆元素相等，或者small比big堆多一个元素。
                            此时表示是平衡的。
                首先把所有元素加入到 small堆(堆顶最大)。 然后从small堆中取 k/2个元素到 big堆中。这样在第一个窗口时，
                small保存的就是窗口内较小的一半，big保存的是最大的一半。 而且 small比big多 0个 或 1个元素。此时是平衡的。
                取中位数 ： 若k为奇数。 那么平衡时，小堆堆顶就是 中位数。 k为偶数时，两个堆顶的平均数就是 中位数。
                记账：  通过一个map: 记录要删除的元素key，和要删除key的数量value. 
                滑动窗口 ： 先将 左侧删除(记账，并修改balance), 然后加入新元素(并修改balance)
                平衡 ： 滑动窗口后，balance可能的值 -2,-1,0,2 不可能是 1
                       0就不需要再平衡了。 对于-2，-1则要把big堆中元素丢入small堆中一个。 如果是2：则small堆中元素丢入big堆中一个。
                销账：只有堆顶元素在 账本中，才将堆顶删除。循环的。只要堆顶在账本中，就一直删除。
                取中位数 ： 销账之后才能取中位数。 然后重读 滑动窗口的步骤。
                
**Q560**        和为K的子数组   ： 和为k的 连续的 子数组   数组元素有负数
                    前缀和 + 哈希表优化
                1. 先得到前缀和数组。把前缀和 key:前缀和 value:key出现的次数 到map中
                2. 遍历前缀和数组，现在就变成了 两数之和 问题。 
                3. 1，2两个过程可以合并在一个for循环中

                连续和问题 -> 前缀和问题 -> hash优化问题。


**Q581**        最短无序连续子数组   如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 要求时间o(n)
                [2,6,4,8,10,9,15]  对 [6, 4, 8, 10, 9] 进行升序排序 整个数组就会有序。输出： 子数组长度为 5
                特点： 子数组的最小值，一定大于等于子数组左侧的最小值。 子数组的最大值，一定小于等于 子数组右侧的最小值。
                方法1 ： 单调栈：数组从左到右入栈(下标)，维持单调递增栈。使用minind记录出栈元素的最小下标。
                        minind是什么？ 根据以上数组，2,6入栈，4会导致6出栈，这个6就是出栈最靠近左侧的位置。这个位置就是子数组的开始。
                        如果后边有一个1，那么就会导致 2出栈，那么2的位置就是出栈最靠近 左侧的元素。
                        同理从右到左入栈，记录 maxind
                        minind 到 maxind就是 子数组。
                        时间 o(n),空间 o(n)
                方法2 ： 1. 找左右 第一个失序的位置。  left,right . 
                        2. 在 left，right之间找 minval最小值, maxval最大值。
                        3. 在0到left找看是否有 大于 minval的值，有的话，最靠近左侧的位置L就是 子数组的开始。
                        4. 同理 找右侧 最靠近右侧 的位置。小于 maxval 的位置R。
                        5. L 到 R 就是 子数组的边界。 

                
**Q697**     数组的度 数组的度的定义是指数组里任一元素出现频数的最大值. 找到最短连续子数组的度和整体度相同。
        方法1：使用map记录，开始位置，结束位置，该字符频率。空间o(n)
             特点：最短子数组中频率最高的元素x，x的频率就是子数组的度, 该子数组一定 以 x开始，并以x结尾。
             那么我们遍历整个数组，得到每个元素在数组中的开始位置start，和结束位置end，还有该元素的频率freq。
             所以这是一个 一对三 的映射关系。 num : (start,end,freq) 使用map<int,int[3]>存储即可。
             最终我们只对freq = k(整体数组的度) 的元素，求 min = Math.min(min, end-start+1) 
        方法2：滑动窗口太细节了。
**方法2没搞懂**  



**Q992**    K 个不同整数的子数组
                
                每变化一次窗口，就判断一次窗口看是否合法。
                K 个不同整数的子数组 ： 若一个区间的数字总类恰好为 K, 那么就合法，找出所有这样的子数组。
                [1,2,1,2,3]
                [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. 子数组的子数组也可能合法。

                固定左边界时，移动右边界若合法res++, 那么可以找到 12,123,1212. 但是若这样，21就无法找到，因为right已经到了3.不能回溯。
                否则复杂度就不是o(n). 

                所以换一种思路。 上边是子数组数字种类恰好为k. 
                现在，我们找数字种类最多为k的子数组数量。 那么对于A数组，他的最多为k的子数组数量n1, 最多为k-1的子数组数量n2
                满足 res = n1-n2.   因为恰好为 k-1,k-2,....1的子数组是相同的。相减就恰好是 恰好种类为k的子数组数量。

                res += right-left;的解释。
                假设本来是 ABC k=3, 然后变为 BCD,那么新的区间数就是 D,CD,BCD.  就是right-left
                right新增加的一个位置，然后以这个位置结尾的区间数，就是新增的。
                若有 12123
                每当right后移动一个位置，就叠加新增的以right结尾的子数组。 
                1 right=0
                2，12 right = 1
                1，21，121  right = 2
                2，12，212，1212，right = 3 然后right++
                次数left要右移动，到  子数字 23  那么又有  3,23, 以3结尾。
                这样就找到了 12123数组的所有数字种类数<=k的数量。


                这其实有集合的思想。 most(k)集合 - most(k-1) 就是剩余的 种类数恰好为k的集合。

**Q1365**     有多少个 小于当前数字 的数字 0 <= nums[i] <= 100
                1.计数排序+前缀和思想 因为nums[i]<100，所以有了计数排序的可能，如果范围很大的话，就不能这么写了。
                         1. 先统计每个出出现的频率， 然后使用sum[i]保存 freq[0到i-1]的和。
                         2. 直接出答案了。
                2. 若nums[i]范围比较大，那么就不能用这个办法。 可以使用单调递减栈+前项依赖的办法。求出的是左侧有多少小于当前数字的个数。
                                同理求右边，然后相加。(存下标)
                   例如 ： 8 1 2  3    栈：81  入栈2导致1出栈， 82  那么比2小的就有1个。(出栈1个)
                   入栈3，导致 2出栈。 出栈1个， 但是比2小的还有一个， 所以，比3小的有两个。 
                   例如： 8 1 1 3 2 4 
        通过栈可知个数     0 0 0 2 2     此时栈为：8 3 2  那么4入栈会怎么样的。  23出栈。 是两个数
                                然后最晚出栈的 3， 比3小的还有两个。 所以比4小的 就有 4个。 
                 每次都是：mincount[i] =  nums[i]导致出栈个数+ mincount[最晚出栈元素k]
                 这样的话只是求出来一侧。 还有从右往左求一次。
                 算法2是错误的 比如  8 1 1 7 4  小于4的就无法得到统计

**JZ35** 
        和上边题做出对比, 上题数据范围小，而且是求数组中，所有小于当前数的个数。
        那么久可以直接计数排序，但是这题是求一侧小于当前元素的个数，那么
        就不能排序，排序后，就无法分清左右了。
        该题使用归并排序。
        对于归并阶段 ： 2 3 6 7     0 1 4 5
        归并时，2 > 0 那么以0为右元素的逆序对就有 20 30 60 70
        然后是1， 2 > 1 那么逆序对就有  21 31 61 71
        然后是4 2<4 4目前构不成  2去掉，数组状态:  3 6 7 - 4 5
        同理3去掉， 合并 6 7 - 4 5  则有 64 74    剩余6 7 - 5
        5： 65 75 然后 归并结束。

        


**Q1423**   可获得的最大点数：cardPoints = [1,2,3,4,5,6,1], k = 3。每次可以从头或者尾部拿一张。
                特点： 最终结果是，取走两侧一段，留下中间一段。
                方法1. 要使得两侧和最大，那么就取长度为len-k的窗口，使得其和最小。
                方法2. 使用前缀和一种极端情况是，都取的左侧，那么就会保留下右侧所有元素。此时left = k-1 right = len-1
                        然后left,right向左移动  两侧的和为  sum[left]+sum[len-1]-sum[right] 求最大值即可。
                方法1，最好。

**滑动窗口内第二大，第二小元素**
**Q1438**    绝对差不超过限制的最长连续子数组  
                0. 窗口内 最大小 - 最小值 <= limit 
                1. 第一反应肯定是单调栈，而且就是单调栈。 使用两个  双端队列的单调栈。一个单增，一个单减
                         1. 对right执行单调栈的入栈操作。
                         2. right入栈后，若当前窗口的最大值-最小值 >limit。 则left++一直收缩。
                         3. left++时，若left元素是队头元素，则把队头删除。因为删除的是最大值，或者最小值。
                                这样就暴露出第二大，或者第二小了。